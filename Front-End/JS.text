                                                  I) Sintaxis y Gramatica                  
                                                
                                                1) Caracteristicas y Gramatica

1) Js Es un lenguaje de alto nivel, Es Interpretado y dinamico (Es un lenguaje Compilado en Tiempo de Ejecucion), Debilmente Tipado (los
valores de las varibles pueden ir variando), MultiParadigma, Sensible a Mayusculas y Minusculas.

2) Los nombres de las varibles deben empezar con una Letra o un $ o un guion bajo.

3) CONST: Una buena practica con las constantes es ponerle un nombre en Mayusculas.

4) UpperCamelCase: Se usa para declarar las clases. EJ: MiClase

5) lowerCamelCase: se usa para declarar variables primitivas o funciones o Objetos o Instancias. EJ: miVariable.

6) Ordenamiento del Codigo: Importacion de modulos, Declaracion de variables, Declaracion de Funciones y Ejecucion de Codigo.



                                                      2) Variables

1) Variable: Un lugar en la memoria donde se guardan datos.

2) var: Con var se declaraban las variables. El Problema es que al usar VAR en estructuras de control o bucles estas no tenian un SCOPE, 
es decir que estas no nacian y morian ahi mismo en esa estructura, sino que existian en un ambito global, un alcance total.

3) let: viene a solucionar el problema del SCOPE de var, esta si posee SCOPE y empieza y termina con las llaves{}

4) const: const basicamente se lo utiliza para declarar varibles constantes, que sabemos que su valor sera estatico en toda la ejecucion.
Tiene la peculiaridad que en Tipos de Datos compuestos no funciona igual, si declaro en un Array una series de valores yo despues le puedo
agregar mas elementos con push(), a pesar de que mi array sea const.
En sintesis, en Tipos de datos primitivos uso const en vez de LET cuando mi variable no va a cambiar su valor nunca, en tipos de datos 
compuestos usare const en vez de let cuando mi variable no mute hacia otra cosa(que pase de ser un arreglo a un objeto, un numbre etc).

5) Sintesis: no usar var porque es mala practica, no sirve para definir funciones en bloque ya que no se definen en el bloque sino antes
y pisa el valor que pueda tener en el ambito global. let viene a resolver estos problemas de var.

6) Objectos: Similar a C# un objeto son atributos con valores. let Persona = {nombre: "Pepe", edad: 35, sexo:"masculino};

7) Array: Es basicamente un conjunto de valores. let array = [1,2,3]

8) Window: Aqui es donde se almacenan todas las variables globales de JS.


                                                    3) Tipos de Datos

1) Primitivos: Apenas los creamos a estos objetos estamos accediendo a su valor. Tenemos: string, Number, boolean, null, undefined, NaN.

2) Compuestos: No accedemos directamente al valor sino a una referencia de donde esta el valor: 1) Object{}. 2) array[]. 3) function(){}.
               4) Class{}.
                                                    3.1) Primitivos

1) string: Es similar a los string de otros lenguajes, los puedo usar con "" o ''.

1.1) Atributos: 1) Length=>Me permite saber la cantidad de caracteres de la cadena, 

1.2) Metodos: 1) ToUpperCase&ToLowerCase()=> Me permiten setear todos las letras a Mayusculas o Minusculas. 2) Include()=> devuelve un 
              T/F si la cadena que le pase por parametro existe en la varible string que ejecuta la funcion. 3) trim()=> elimina los 
              espacios en blanco de los margenes. 4) split()=> esta funcion me permite generar un arreglo, por parametro le tengo que 
              pasar cual sera el caracter que separara cada elemento del array (si es por comas, puntos, espacios). 5) Slice(num)=> este
              metodo me permite seleccionar desde que posicion de la cadena de caracteres quiero seleccionar. 6) CharAt()=> a este 
              metodo le tengo que pasar la posicion del caracter que quiero extraer. 7) CharCodeAt()=> similar al anterior pero en vez
              de devolver el caracter devolvera su codigo. 8) concat() al igual que en SQL es para concatenar texto, tiene la particularidad,
              que si se lo asigno a un ARRAY concatenara sus valores. 9) endsWith()=> este metodo devuelve un T/F si la cadena termina con el
              parametro que le pase. Tambien le puedo pasar un parametro numerico que es la cantidad de caracteres a evaluar, en caso de que 
              quiera evaluar solo una parte y no toda la cadena.
              5.1) Slice(num1,num2): tiene una segunda funcion que es cuantos quiero caracteres quiero agarrar segun la posicion en la que 
              estoy.

1.3) Interpolacion-Strings: Interpolar es basicamente meter dentro de una cadena una variable. Para ello en JS deberemos usar Template-Strings
                            Para hacer la interpolacion deberemos usar ``, ya dentro de la cadena cuando queramos llamar a la variable para
                            colocarla dentro de la cadena lo haremos asi: ${variable}. Tambien esto me permite tener las cadenas con saltos
                            de linea.
EJ: let nombre = "Pepe Mujica"
    Console.Log(`Hola Soy ${nombre}`) // print: Hola soy Pepe Mujica

2) numbers: Son numeros, de todo tipo, no se diferencian ni por tamaño ni por decimales

2.1) Atributos:

2.2) Metodos: 1) ToFixed(1) => a este le tengo que pasar cuantos numeros decimales quiero que tenga mi numero. 
              2) Number.parseint(num) => me devulve solo el numero entero. Puede recibir un string, por lo cual puedo formatear un numero en 
              cadena de texto a entero numerico.  3) Number.parseFloat()=> lo mismo pero para valores flotantes. 4) Number.IsInteger()=>
              define si un numero es o no entero. 5) valueOf()=> me devuelve el valor de un number.

parseint o float no salen de la variable number debido a que estos pertenecen a la clase number, a diferencia de los otros metodos. Es 
decir que estos metodos dependen de un Constructor.

3) Booleans: es lo mismo de siempre

4) null: es un valor que solo el programador le puede asignar a la variable, a diferencia de otros lenguajes. Representa la ausencia de 
valor

5) undefined: Es una variable la cual no fue inicializada nunca. Representa la ausencia de valor.

6) NaN: Puede aparecer cuando queremos realizar operaciones aritmeticas con elementos que no son numeros.


                                                        3.2) Compuestos

1) ARRAYS: Un ARRAY basicamente es una coleccion de elementos, a diferencia de C# puedo coleccionar elementos de diferente tipo, incluyendo
objetos y otros ARRAY. Para acceder a la posicion del elemento de un ARRAY tengo que poner [numero].

const a = ["StringPicante", ["Elo", "Xd"]]
console.log(a[1][1] //Imprime Xd).

1.1) Propiedades Array: 1) Length.

1.2) Funciones Array: 1) ArrayOf()=> me permite declarar un array. 2) Array(lugares).fill(valores)=> me permite rellenar automaticamente 
todas los valores de un array. 3) push()=> me permite agregar elementos al array. 4) pop()=> Elimina el ultimo elemento.  
5) ForEach()=> Esta funcion me permitira pasarle un metodo el cual se ejecutara tantas veces como elementos haya en el array. Con el primer
valor recorreremos el valor del elemento y con el segundo parametro su posicion.

    arrayColores.forEach(function(item, posicion){
        Console.Log(item, "  ", "posicion");
    })


2) Objetos: Combiene declarar los objetos como CONST debido a que con esto nos evitamos de que este objeto cambie su referencia. Un objeto
es un conjunto de atributos y/o Metodos. Sus atributos pueden ser de cualquier tipo de dato ya sea complejo o simple. Tambien puede tener
metodos.

    const Persona = {
        nombre: "MaxiPijama",
        apellido: "Sar Fernandez",
        edad: 33,
        Habilidades: ["C#", "TS", "SQL"]
        Contacto:{Email:"Pijama@gmail", Numero: 353456, Pagina:"ElPentagono"}
        Saludar(){return "Holanda de 74"}
    }

3) THIS: Hace referencia a las variables o funciones que estan dentro de ese SCOPE. Si yo pongo dentro de mi objeto THIS voy a poder 
referenciar a todos los elementos que esten dentro de mi SCOPE.

DATO: Acceder al Valor por referencia: Lo que quiere decir esto es que para tener el valor de un elemento compuesto debo colocar el espacio
de la memoria al cual quiero acceder para rescatar cierto valor.

                                                        4) Funciones

1) Es un bloque de codigo independiente al bloque de codigo global. Las funciones tienen como tarea realizar una accion especifica. Pueden
tener parametros, pueden o no devolver un resultado. A diferencia de otros lenguajes en JS las funciones se consideran objetos. Las funciones
son de primera clase como en C# (Se pueden pasar como argumentos, retornar su valor a una asignacion). Estas se llaman funciones declaradas

        1.1) function FuncionDeclarada(){

        }

2) A diferencia de otros lenguajes no debo especificarle si es VOID o no ni el tipo de dato que va a retornar, si quiero devolver algo 
pongo un return y le adjunto el valor a devolver.

3) Parametros: En JS la funciones tambien permiten parametros, pero estos no tendra la declaracion de el tipo, solo pondremos el nombre
de las variables en la declaracion. Si llamo a la funcion sin los parametros no dara error pero los valores seran undefined. Tambien le 
puedo dar valores por defecto a mis parametros.

4) Funciones anonimas: Basicamente es crear una variable a la cual le voy a asignar el valor de una function. Esta variable normalmente
sera una CONST. Se lo llama funcion anonima debido a que la funcion no tiene nombre. A diferencia de las otras funciones yo a esta 
no la puedo llamar antes de declararla sino nos dara error. Estas Funciones Anonimas Expresadas son mejor practica que las clasicas 
funciones.

const FuncionExpresada = function(){return "Hola"} //

let variable= FuncionExpresada(); 
console.Log(variable); //"Hola"

                                                     5) Operadores Relacionales

1) >: Mayor a 
2) <: Menor a 
3) >=: Mayor o Igual a 
4) <=: Menor o Igual a 
5) ==: Son comparacion de valores, compara si los valores 2 elementos son iguales (Ignora su tipo de dato), mala practica.
6) ===: Compara tanto el valor como el tipo de dato, esta se usa al considerarse la buena practica.
7) !=:
8) !==:


                                                    6) Estructuras de Control 
                                                    
1) Estructuras de Control: Es el Mecanismo que permite controlar el flujo de ejecucion de la aplicacion. Segun resultados,acciones o 
X estimulos la programacion se ejecutara por distintos flujos. 1) Las Estructuras secuenciales son las estructuras con un solo flujo de 
ejecucion, una linea tras otra. 2) Las Estructuras condicionales Bifurcan el flujo, segun la condicion se cumpla o no se ejecutara un 
flujo u otro. (if, else if y else), (operador ternario) y (Switch) 3) Las Estructuras Repetitivas (For, While, Do While)

2) Ternario: let variable = (condicion que devuelve T/F) ? "Caso True" : "Caso False".`

3) ForIN: Esta me va a permitir recorrer/iterar las propiedades de un objeto, recorre el interiror de un objeto, su sintaxis en muy 
similar a un ForEach. Para acceder a los valores de la propiedad las debo colocar entre [""]. Se lo utiliza para objetos primitivos 
(No iterables)

    For(const prop in Persona)
    {
        Console.Log('Propiedad ${prop} Valor ${Persona[prop]}')
    }

4) ForOf: Es Basicamente un ForEach, me permite recorrer un ARRAY o cadenas, basicamente listas. Se lo utiliza para objetos Iterables.

                                                        7) Manejo de Errores

1) Funciona con el Clasico Try-Catch-Finally.

2) throw: Sirve para lanzar la excepcion, el por defecto es ERROR.

                                                        8) Break y Continue

1) Break lo que hace basicamente es terminar con la ejecucion de un Ciclo o de un Switch.

2) Continue: Se salta la vuelta del ciclo en la que se ejecute.

                                                        9) Destructuring

1) Destructuring: Es una nueva forma de asignar valor a arreglos y objetos en JS. Esto es para ahorrar lineas de codigo en la asignacion
                  En el caso de los objetos para que la destructuracion funcione necesito que el nombre de la variable sea igual al nombre 
                  del atributo del cual quiero extraer el valor, sino cumplo esto mi variable sera undefined.

                  const array = [1,2,3]
                  let [PrimerElemento, Segundo, Tercero] = array 

                  const Persona = {nombre: "Hernan", apellido: "Pastrami", edad: 33}
                  let {nombre, apellido,edad} = Persona

                                                        10) Objetos Literales

1) Los objetos literales son basicamente una nueva forma de escribir atributos y Metodos. En el caso de los atributos si ya tengo atributos
con el mismo nombre de mi propiedad JS entendera que quiero tomar esos valores asi que los asignara automaticamente.

       let nombre = "Pipo",
       let Apellido = "Argenti";

        const JugadorRacing = {
        nombre,
        Apellido
        }   

                                                11) Parametros REST y Operador SPREAD

1) Parametros REST: Se utiliza en los casos de que no se cuantos valores o parametros voy a recibir o tener en un arreglo. A este
parametro se lo Representa con "...". Por Ejemplo en el caso de sumar numeros cuando no se cuantos numeros sumar puedo usar parametros
REST. Para esto al parametro REST lo vamos a tratar como un ARRAY, ya al no saber cuantos valores son lo vamos a usar como un ARRAY. El
Parametro REST solo se ejecuta en los parametros de una funcion.

    function Sumar(a,b, ...c){
        let resultado = a+b;

        c.forEach(function(numero){
            resultado+=numero;
        })
    }

2) Operador SPREAD (operador de propagacion): Con el SPREAD puedo concatenar ARRAYS/OBJETOS y puedo crear copias exactas de los objetos, 
una copia con su propia referencia.

        const array3 = [...array1, ...array2]
        const objeto3 ={
            ...objeto1,
            ...objeto2
        }


                                                        12) ARROWS FUNCTIONS

1) Son una nueva forma de definir funciones anonimas Expresadas (const FuncionExp = function (){}). La sintaxis es la siguiente:
    const ArrowFunction = ()=>{}

2) En el caso de que no tenga parametros la ARROW_FUNCTION deberemos colocar parentesis, si tiene un parametro no hara falta.
   const FuncionExp = nombre => {}
   FuncionExp("Generico");

3) Tambien en su escritura si solo tiene una sola linea de codigo esta realizara un return implicito.

4) Declarar Metodos dentro de objetos literales con ARROW_FUNCTION puede ser un problema debido que al declarlo si yo uso THIS no apuntare
dentro del objeto sino que apuntare hacia el ambito global. Esto es porque las ARROW_FUNCTION apuntan hacia el contexto en el cual se 
encuentra su objeto padre. En sintesis es de mala practica crear ARROW_FUNCTION dentro de objetos literales.


                                                        13) Prototipos

1) Prototype: Es una propiedad que tienen todos los elementos de JS. El Prototipo es un objeto que funciona como una plantilla que proporciona
metodos y propiedades que el objeto puede usar.

1.1) La razon de la existencia de prototype es que los objetos puedan heredar caracteristicas entre si, lo cual es util cuando quiero
que varios objetos compartan metodos y/o propiedades.

2) Las clases de JS en momento de compilacion transforman las CLASES a Funciones Prototipales, porque la POO de JS se encarga mas del Manejo
de prototipos que el manejo de CLASES. Este solo simula un manejo de clases en su sintaxis, pero realmente  maneja prototipos.

3) Para Construir un prototipo yo puedo hacer uso de una funcion constructura. Para que la funcion constructura funcione debo colocarle
tanto a sus metodos como propiedades la palabra THIS.

    function Constructora(nombre, edad){
        this.nombre = nombre;
        this.edad = edad;
    }

4) Para llamar a la funcion constructora deberemos llamarla con NEW: const persona = new Constructora("Jose", 33);

5) Por temas de rendimiento en los prototipos no se suelen colocar metodos, sino solo los atributos. Para agregar metodos a un prototipo lo
que hago es llamar a la funcion constructora, a la propiedad prototype  y agregar la declaracion de la funcion. Basicamente los metodos
no se lo agregamos a las instancias de los objetos sino al prototipo de este. Esto es la herencia Prototipica.

    Constructora.prototype.Hablar = function (){};

6) A partir de las clases a nosotros ya no nos hace falta construir estos prototipos, solo necesitamos crear las Clases y JS al compilar
creara estos constructores de prototipo por nosotros.

                                                        14) Herencia Prototipica

1) function Perro(nombre, edad, tamanio){
    this.super = Animal;        //IGUALO SUPER AL PROTOTIPO ANIMAL
    this.super(nombre, edad);   // PASO PROPS DEL Constructor ANIMAL.
    this.tamanio = tamanio;
}
Perro.prototype = new Animal();
Perro.prototype.constructor = Perro;

En el bloque de la funcion estoy definiendo de donde va a sacar sus atributos perro, en este caso le creamos una clase super que heredara
de un objeto Animal, esta clase determinara su nombre y edad, y luego ponemos su prop de tamanio como hacemos normalmente, ahora para 
completar la herencia le debo pasar a perro ese objeto Animal, esto para que el prototipo de perro herede todas las caracteristicas del
prototipo animal, por eso es que sin ello no se completa la herencia.

2) Polimorfismo Prototipo: Perro.prototype.Sonido = function () {}

Sintesis: Super se convierte en la funcion constructora de animal la cual le pasa tanto nombre como edad, luego termina de colocar tamanio.
Con esto ya se heredo los atributos, pero no los metodos, para esto decimos que el prototype de Perro es el de Animal, con esto heredamos
las propiedades.


SINTESIS PROTOTIPO: Es una especie de auxiliar, en el puede tener atributos y/o propiedades que las puede reutilizar una clase, solo 
llamando a su prototipo. Para heredar el prototipo de una clase es tan sencillo con hacer un new CLASE();

                                                    15) Clases y Herencia

1) Las clases lo que hacen basicamente es simplificarnos la escritura, al final por detras todo funciona con prototipos y no clases,
pero las clases nos simplifican la forma en que declaramos objetos, heredamos y construimos prototipos. 

class Animal{
    constructor(nombre, edad)
    {
        this.nombre = nombre,
        this.edad = edad
    }

    Sonido(){
        Console.Log("Hola Papu")
    }
}

2) Para realizar la herencia es tan simple como utilizar la palabra reservada extends. Luego en el constructor le tengo que pasar todos 
los parametros que reciba su constructor. Los parametros que sean configurados de su padre los pondremos en super(), en los otros seguiremos
el modelo this.

class Perro extends Animal{
    constructor(nombre, edad, raza)
    {
        super(nombre, edad);
        this.raza = raza;
    }

    Sonido(){
        Console.Log("Viva Peron")
    }
}
                                         16) Metodos Estaticos, Getters y Setters

1) En JS no existen las clases privadas, por ende todas las clases son public.

2) Si existen los metodos Static, pero funcionan un poco distinto, puedo volver a un Metodo Static sin la necesidad de volver a mis clase
Static. Luego el llamado es igual. Como Dato las clases Static no aparecen en los prototipos.

class Prueba{
    static Saludo(){
        Console.Log("Hola")
    }
}

Prueba.Saludo();

3) A diferencia de C# yo debo crear Metodos GETERS y SETERS. El Metodo Get lo unico que suele hacer es un Return a la propiedad que quiero
recuperar. En los Seters se recibira un parametro que sera el valor de mi propiedad. Para indicar que no son metodos comunes le antepondremos
las palabras get y set respectivamente.

class Persona
{
    constructor(nombre, apellido)
    {
        this.apellido = apellido;
        this.nombre = nombre;
        this.edad = null;

        get GetEdad()
        {
            return this.edad;
        }

        set SetEdad(edad)
        {
            this.edad = edad;
        }
    }
}

3.1) Para tener en cuenta que estas funciones GET y SET en tiempo de ejecucion las transforma en propiedades/atributos y no metodos, por
ende la debo tratar como tal.

let edad = persona.GetEdad;
persona.SetEdad = 33;


                                                        17) Objeto Console

1) .Log: Me permite enviar mensajes a la consola. 2) .Error: Me permite enviar errores a la consola. 3) .warn: Me permite enviar warnings.
4) .Info: Para un mensaje informativo. 5) .Clear: Limpia la consola. 6) .dir: Me permite mostrar por consola un elemento en formato objeto.
7) .Group: Me permitira crear grupos de mensajes por consola, todos los consoles log por debajo perteneceran al grupo hasta que lo 
corte un .GroupEnd. 8) .table: Me permite leer un elemento en forma de tabla. 9) .time: Me permite saber el tiempo que tarda en realizarse
una peticion, este para al llamar al console.timeEnd(). 10) .count: Cuanta cuantas veces se ejecuto un bloque de codigo.
11) .Assert: Me permite hacer prueba unitarias, pasandole una condicion y los valores a evaluar por array.

console.Assert(x<y,[x,y,"Error, X debe ser menor a Y"])


                                                        18) Objeto Date

1) Es el objeto base de las fechas, es el equivalente a DateTime. Si creo un objeto de DATE puedo acceder a sus Metodos.

2) Metodos: 1) GetDate(): Me permite extraer el dia del mes en formato number. 2) GetDay(): Me permite extraer el dia de la semana en formato 
number (D-0, L-1, M-2, M-3, J-4, V-5, S-6). 3) GetMonth(): Me permite obtener el mes en formato number, esto cuenta del 0 al 11.
4) GetFullYear(): Me permite obtner el año en formato number. 5) GetHours(): Obtengo la hora en formato number. 
6) getMinutes(): Obtengo los minutos en formato number. 7) getSeconds: obtengo los segundo en formato number. 8) getMilisegundos(). 
9) toDateString(): Me permite obtener la fecha (dia de la semana, Mes, dia numerico de mes y año) en forma de cadena de texto.
10) toLocaleString(): la forma mas clasica de representar la fecha. D/M/Y h:m:s. 11) toLocaleDateString: d/m/y. 
12) toLocaleTimeString: h/m/s. 13) Date.now(): Muestra numericamente cuantos segundos pasaron desde 1970, se lo conoce como timeStamp.
14) getTime(): Me permite obtener el timeStamp de una fecha.

Moment.JS => Libreria para manejar el tiempo.

                                                      19) Objeto Math

1) .ABS(): Me devuelve el valor absoluto de un numero. 2) .CEIL(num): Redondea para arriba. 3) .FLOOR(num): Redondea Hacia abajo. 
4) .ROUND(num): Redondea al mas cercano. 5) Sqrt(num): Me permite sacar la raiz cuadrada de un numero. 6) POW(num1,num2) Me permite elevar
el numero a alguna potencia, num1 sera la base y num2 la potencia. 7) .Sign():Evalua si un numero es positivo, negativo o cero. 
8) .Random(): Me devolvera un Numero Random entre 0 y 1 console.log((Math.random()*1000).toFixed(0));

                                                    20) Operador CortoCircuito

1) CortoCircuito OR: Cuand el valor de la izquierda en la expresion siempre pueda validar true, es el  valor que se cargara por defecto.
es decir que si el valor de la izquierda no es undefined se cargara ese valor.

function Saludar(nombre){
    nombre = nombre || "Desconocido";
    console.log(`Hola ${nombre}`)
}
En este caso si nombre no tiene un valor definido nombre se cargara con el valor de Desconocido, si tiene un valor lo mantendra. Los 
valores false, null, undefined, "" y 0 seran los que haran que se elija la opcion de la derecha.

2) CortoCircuito AND: Cuando el valor de la izquierda en la expresion siempre valide false, es el valor que se cargara por defecto, es el
opuesto al CortoCircuito de OR.

SINTESIS: Cuando la opcion de la izquierda tienda a TRUE devolvera la opcion de la izquierda en el Operador OR. Cuando la opcion de la 
izquieda tienda a false esta devolvera la de la izquierda cuando usemos el operador AND.

                                                  21) Alert, Confirm y Prompt

1) Estos metodos vienen del objeto padre Window. Estos 3 metodos me permitiran interactuar con el usuarios.

2) Alert: me permite mandar un mensaje de alerta al usuario, solo tiene la opcion de aceptar. No es necesario guardar esta en una variable,
ya que su resultado siempre sera undefined.

3) Confirm: Manda un mensaje al usuario con las opciones de aceptar o cancelar. Si la guardo en una Variable depende cual boton toque 
esta devolvera un T/F.

4) Prompt: Manda un mensaje al usuario y le permite ingresar un valor. Al guardarla en una variable guardara el valor que le coloquemos
en el input, en el caso de que apretemos aceptar. Si presionamos cancelar devolvera null.

                                                    22) Expresiones Regulares

1) Expresion Regular: No es mas que una secuencia de caracteres que forman un patron de busqueda de cadena de texto. Tambien se las conoce
como Regex. Me sirve para validar formatos de texto, por Ejemplo mails, contraseñas con X reglas o exclusiones de caracteres.

2) Declaracion: 1) let regex = new RegExp("","flags"); 2) let regex = /regex/

3) Metodos: 1) test(): Verifica si la cadena que le pase cumple con el regex, devuelve T/F. 2) exec: Este devuelve un arreglo con la palabra
buscada, la posicion en la que se encontro y la cadena completa.

4) Comodines: Son determinadas reglas que le agregaremos al patron REGEX. 1) i: ignora mayusculas y minusculas. 2) g: busca todos los 
elementos que matcheen no se queda con el primero. 3) \d: valores Numericos. 4) \D: Valores NO numericos. 5)

                                            23) Funciones Anonimas AutoEjecutables

1) Estas son un patron de diseño, luego de ser declaradas estas funciones procederan a ejecutarse. Estas pueden ejecutar funciones 
asincronicas o limpiar el entorno global. Estas obligatoriamente necesitan de un punto y Coma.

2) Sintaxis: (function (d,w,c) {//Codigo})(document, window, console);

                                                        24) Modulos

1) Los modulos vienen a reemplazar las Funciones Anonimas AutoEjecutables. Lo que hacen los modulos es llamar un archivo de JS dentro 
de un archivo JS.

2) Para poder realizar importaciones de modulos en JS debo declarar mi script de JS  en HTML y agregarle el atributo type="module"
   <script src="js/modulos.js" type="module"></script>

3) Exportar Variables: export const Pi = Math.PI;__Sin la palabra reservada export la variable no se podra exportar hacia el modulo de JS
   Exportar funciones: export function restar(a,b) { return a-b}
   Exportar Objetos: export const aritmetica = {Sumar(a,b){return a+b}, Restar(a,b){return a-b}}

3.1) Exportar Default: export Default Sumar(a,b){return a+b}; Solo puedo tener un elemento exportado por Default.

4) Importar: Import {Pi} from "./miarchivo.js"; Import {restar,sumar, aritmetica} from "./aritmetica.js";

4.1) Importar Default: Import Sumar,{restar} from "./aritmetica.js"

5) Export Default variables: Para hacer un export default de una variable deberemos hacerlo luego de su declaracion. 
                   EJ: const nombre = "Pepe";
                       export default nombre;

6) Alias: Import {Pi as numeroPi} from "./miarchivo.js";


                                              25) Datos Practicos de los ejercicios

1) typeof: me permite evaluar el tipo de una variable. If(typeof cadena == 'string') 

1.1) Otra forma es hacer:  if(cadena.constructor === String)

2).: Tiene 2 funciones, la que recibe un parametro me permite decir en que posicion de la cadena quiero comenzar. La que recibe 2
paramtros me permite decidir tanto desde que posicion empezar y cuantos caracteres quiero agarrar desde esa posicion.

3) Operador ternario dentro de operador ternario: const aux = (x>y)? "Es Imposible": (x!=33)? "Enserio?": "Sabe Cosas"

4) Join(): Metodo de ARRAY que me permite juntar todos los elementos de ARRAY con separadores personalizados.

5) Split(): Si no le paso ningun caracter esta separara todos los caracteres en elementos de un arreglo.

6) "": tiende a falso

7) IndexOf(palabra, Comienzo): Este metodo se usa para cadenas de texto, si encuentra la palabra que le pasamos por parametro devolvera el
index de la primera letra de la palabra, si no encuntra la palabra devuelve -1. Tambien le puedo pasar un segundo parametro, este definira
desde que parte de la cadena quiero evaluar.

8) 1) Con esto construyo una fecha. 2) Declaro un objeto tipo Date. 3) Calculo la fecha, debo convertirlos a timeStamp con getTime(). 
   4) Construyo una nueva fecha con el resultado timeStamp. 5) Imprimo pero restando 1970 ya que es el año base donde comienza el 
   timeStamp.

    1) const fecha = new Date(y,m-1,d);
    2) let fa = new Date();   
    3) fa = (fa.GetTime() - fecha.GetTime());
    4) const resultado = new Date(fa);
    5) console.log(resultado.getFullYear()-1970)

9) InstanceOf: Es igual que el typeof pero para variables compuestas.
               if(!fecha instanceof Date) return console.warn("Coloque una fecha valida");

10) RegExp Mail: /[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i

11) map(): Me permite acceder a todos los elementos del array y manipularlos, y de paso esto se lo puedo asignar a un array nuevo
const newArray = array.Map(el=>el*el);

12) Ordenar Array Numerico: array.sort((a,b)=>b-a)

13) SET: Set es un elemento que me permite construir un array nuevo en el cual no se permitiran elementos duplidos. La Naturaleza del
set es generar elementos sin duplicaciones.
         [...new Set(array)]

14) const prom = array.reduce((acu, item)=>{return acu = acu + item},0);

15) Cuando JavaScript intenta convertir un objeto a una cadena, obtienes [object Object]. Para solucionar esto, puedes convertir el 
objeto a una cadena JSON utilizando JSON.stringify().

16) Filter(): Con filter puedo hacer varias funciones, una de ellas es comparar elementos con todo el array:
                Filter((value, index,self)=>self.IndexOf(value)===index)

Lo que hago aca basicamente es con filter construir un nuevo arreglo, value extrae los valores del array, index las posiciones y self el
array original. Luego lo que hago es construir el array con los indices del array viejo. Aca esta la clave lo que hago es que voy a buscar
el index de todos los valores del array original y lo voy a comparar con el index para ver si existe. El truco para evitar repetidos es
el IndexOf, ya que este buscara siempre el indice del primer elemento que encuentre, si esta repetido se quedara con el  array del que 
este mas cerca, de esta forma cuando venga un dato repetido solo pisara el anterior pero nunca se colocaran 2 elementos repetidos gracias 
al IndexOf().

17) Array.Includes(): me permite ver si los elementos de un array existen en otro Array. Devuelve un T/F.

 for(let item of array)
 {
    array2.incluedes(item);
 }

                                             II) Programacion Asincrona


                                                26) Temporizadores

1) SetTimeOut: Este recibe una CallBack (una funcion como argumento) y una declaracion en MiliSegundos de del tiempo que es
en cuanto tiempo se debera ejecutar la CallBack.
setTimeout(()=>{
 console.log("Hola")
}, 5000)

1.1) El cancelador del SetTimeOut es el ClearTimeOut(setTimeout), para esto debo guardar mi setTimeOut en una variable y pasarle esa
variable al ClearTimeOut.  

2) SetInterval: Es un igual que el SetTimeOut solo que este se ejecuta segun el intervalo de tiempo que le establezcamos.
setInterval(() => {
    console.log("Copy")
}, 1500);

2.1) El cancelador del SetInterval es el clearInterval(), funciona igual al ClearTimeOut.

                                                27) Asincronia y EVENT LOOP

1) La Asincronia es uno de los pilares principales de JS, ya que JS es un lenguaje que solo trabaja con un hilo, por ende solo puede 
ejecutar una cosa a la vez.

2) EVENT-LOOP: El EVENT LOOP basicamente es la forma en la que tiene JS de ejecutar sus tareas. Aquellas funciones o metodos que dependan
de APIS externas seran las ultimas en ser llamadas ya que el EVENT LOOP primero se encarga de ejecutar todo lo que tenga el SCRIPT principal
y luego lo provenientes por APIS externas, es decir el EVENT LOOP ejecuta el script principal y almacena las peticiones de APIS externas, 
(TASKS) cuando termina el flujo principal procesa las TASK/APIS.

3) Macro-Task: Son las tareas que tienen su propia pila de ejecucion y un elevado consumo de memoria. Esta es el SCRIPT principal o alguna
api que generemos con SetTimeOut(). 3.1) Micro-Task: Las promesas son pequeñas tareas que se ejecutaran luego terminado la Macro-Task 
principal.

5) Operaciones I/O: Son operaciones de entrada y salida, ante la entrada de datos se devolvera una respuesta. El proceso es el ABC de la 
programacion, el usuario introduce datos, el programa lo procesa  y segun lo que procese devuelve datos. Estas son las que mas se ejecutan 
en JS.

6) Operaciones Concurrentes: Es cuando 2 o mas tareas progresan simultaneamente. La diferencia con la paralela es que puede ser que una 
de estas tareas que progresan a la vez no necesariamente comenzaron a vez a diferencia. 7) Operaciones Paralelas: Es cuando 2 tareas se 
inician al mismo tiempo y se ejecutan a la par.

8) Operacion Bloqueante: Son aquellas que bloquean el hilo de ejecucion en la espera de termino de un proceso (sincrono).8.1) Lo opuesto 
son las no Bloqueantes que durante la espera deja que el Hilo de Ejecucion se libere y realice otras tareas (Asincrono).

9) Operacion SYNC/ASYNC: Se diferencia por cuando tendra la respuesta, si es en el inmediato es sincrono, si no se sabe cuando se tendra
la respuesta es Asincrono, la ASYNC no espera el resultado y suelta el hilo hasta que el resultado sea devuelto.

10) Codigo en JS: El codigo de JS sera Single-Thread, de operaciones I/O y: 1) Codigo Sincrono Bloqueante. 2) Codigo Asincrono 
No-Bloqueante.

11) SINTESIS EVENT LOOP: JS funciona con un solo hilo de ejecucion y con operaciones de I/O. La ejecucion de las tareas asyncrona es la 
siguiente: 1) En mi stack principal voy llamando las tareas, aquellas de indole asincrona de Espera se van hacia el modulo de Web APIS
y se realiza su espera pero liberando el hilo, una vez estas terminan de ejecutarse van a la cola de espera de las CALLBACKS. Cuando 
termina de ejecutarse el hilo principal de la aplicacion el EVENT LOOP busca aquellas funciones que hayan quedado en la cola de las 
callback y las ejecuta.


                                                        28) CallBacks

1) CallBack: Una CallBack basicamente es una funcion que se pasa como argumento a una funcion y luego se le utiliza o se la re-llama dentro
de la ejecucion del codigo. Cuando declaro la funcion como argumento no se ejecuta, sino que solo la declaro, luego en el codigo de la 
funcion la llamare.

// DECLARO CALLBACKS
const CallBack = (array,rellamda) =>{
    array.push("El Papu");
    rellamda(array);
}
//LLAMO LA FUNCION Y DECLARO EL CALLBACK
CallBack(names, (array)=>{
    console.log(`Se agrego un elemento: ${array.reverse()[0]}`)
})

2) Los CALLBACKS tambien son uno de los mecanismos que nos da JS para trabajar con asyncrona, el problema que presenta esta es el callback
Hell que es la llamada de muchos callback lo que genere un codigo poco legible.

3) Control Async: Estos Callback me permiten ejecutar los procesos de forma ordenada al anidar CALLBACKS dentro de callbacks, lo ejecucion
sera en el orden de anidamiento. El motivo de esto es debido a que al anidar callbacks estoy pidiendo que se complete la primera operacion
asincrona antes de que se ejecute la anidada. Estás creando una dependencia entre las operaciones asíncronas, donde la segunda operación no 
puede comenzar hasta que se complete la primera.

CallBack(names, (names)=> {
    console.log(names[0])
    CallBack(names, (names)=> {
        console.log(names[1])
        CallBack(names, (names)=> {
            console.log(names[2])
            CallBack(names, (names)=> {
                console.log(names[3])
            })
        })
    })
})

                                                          29) Promesas

1) Una Promesa es una especie de IF-ELSE, donde si la promesa se cumple se ejecutaria el Bloque RESOLVE, sino el REJECT. Las promesas 
reciben 2 funciones que son el RESOLVE y el REJECT. Estas Vienen a reemplazar a las CALLBACKS ASYNC.

2) Dentro de la PROMISE ira todo nuestro codigo, en este colocaremos el RESOLVE en el lugar donde veamos que se cumplen correctamente la 
accion. En los parentesis del resolve ira lo que queramos devolver de nuestra promesa

const Promesa = (array) =>{
    return new Promise((resolve, reject)=>{
        setTimeout(() => {
            resolve(array);
        }, Math.random()* 1000);
    }) 
}

3) Metodos para Trabajar la ASYNC con PROMISE: 1) THEN():  Este recibira el resultado del Bloque RESOLVE(). Dentro de sus parametros le 
pasaremos un CALLBACK con el cual podremos manipular el resultado del RESOLVE. Tambien en esta callback de THEN puedo retornar el elemento
y pasarselo a un THEN() para que lo manipule. Con Esto tambien tengo la ventaja de que cada then() se ejecutara al termino del anterior.
2) CATCH(): Este se encargara de capturar el error que devuelva el bloque REJECT, la ventaja de esto es tener una sola validacion para 
todas las promesas.

3.1) Promesa(names)
     .then((array) => {console.log(array[0])}
            return array;)
     .then((array)=> {console.log(array[1])}
          console.log("END"));

3.2) Promesa(names)
     .then((array) => {console.log(array[0])}
            return array;)
     .Catch(err => console.error())

4) SINTESIS: Las promesas son ASYNC debido a que la ejecucion de estas puede que tenga periodos de espera, es por ello que ante algun evento
que genere una espera la PROMISE permite la liberacion del HILO de ejecucion para otras tareas, cuando la promesa se termine con el bloque
RESOLVE o REJECT esto va hacia la cola de CALLBACKS y ahi lo recoje el EVENT LOOP. Con el THEN() Manipulo el objeto que devolvio la promesa
y puedo manipularlo en varios THEN(), el CATCH() en para el error.

                                                     30) Async - Await

1) Esto tambien me permite trabajar con Asincronia, aunque no viene a reemplazar las promesas sino las complementa. Para manejar los errores
de funciones ASYNC usamos TRY-CATCH.

async function funcion(){}

2) Al igual que en C# para aquellas acciones asincronas yo debo colocar AWAIT, debido a que esta ademas de liberar el hilo de ejecucion
parara la ejecucion de esa funcion, porque sino la funcion Asincrona esperara resultados de la API pero mi funcion principal nunca
paro a esperar los resultados y siguio de largo.

async function funcion(){
    Try{
    let nombres = Await NombresBD(); => NombresBD() Maneja Promises.
    return console.log(nombres);
    }
    Catch(error)
    {
        console.error(error) 
    }
}

const funcion = async () =>{}

3) Esto me permite ahorrarme la concatenacion de THEN(), basicamente las funciones ASYNC me permiten Emprolijar la sintaxis de las 
promesas, pero no las reemplazan.

DATO ASYNC: Async no es solo liberar el HILO de ejecucion sino que tambien es la capacidad de parar la ejecucion lineal de la funcion, 
la pausas hasta que tu proceso ASYNC se complete.


4) SINTESIS ASYNC : 1) Los Callbacks ya no se usan por tema de legibilidad. Cuando estos utilizan un setTimeOut() el stack de compilacion 
de JS lo envia a la pila de WEB API (maneja las tareas ASYNC, las de larga duracion) una vez terminada va a la cola de Callbacks y ahi
la rescata el EVENTLOOP. Al concatenar Callbacks me permite ejecutar ordendamente y asincronamente tareas. 2) Las Promesas al igual que 
los Callbacks al utilizar alguna operacion asincrona (solicitudes de red, lectura de archivos, APIS, setTimeOut) pasara a la cola de las
WEB API y esperara el cumplimiento de las promesas para pasar a la cola de CALLBACKS. En THEN() generaremos un CALLBACK donde
manipularemos el resultado del RESOLVE(). 3) Las funciones ASYNC son una forma de mejorar la escritura de las promesas, la declaracion
del RESOLVE y el CATCH es igual, solo que al llamar la funcion con la promesa le colocaremos la palabra AWAIT para que aguarde la ejecucion
y libere el HILO, puedo guardar el resultado en una varible si necesito conservar y manipular el objeto.

LAMBDAS: Parece que las ARROW_FUNCTION y las LAMBDAS de C# son casi iguales. Las LAMBDAS me permiten declarar funciones anonimas de un 
parametro con un Return implicito.

                                                        31) Symbols

1) Es un nuevo tipo de dato de JS