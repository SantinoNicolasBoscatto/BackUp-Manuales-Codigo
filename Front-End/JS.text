                                                  I) Sintaxis y Gramatica                  
                                                
                                                1) Caracteristicas y Gramatica

1) Js Es un lenguaje de alto nivel, Es Interpretado y dinamico (Es un lenguaje Compilado en Tiempo de Ejecucion), Debilmente Tipado (los
valores de las varibles pueden ir variando), MultiParadigma, Sensible a Mayusculas y Minusculas.

2) Los nombres de las varibles deben empezar con una Letra o un $ o un guion bajo.

3) CONST: Una buena practica con las constantes es ponerle un nombre en Mayusculas.

4) UpperCamelCase: Se usa para declarar las clases. EJ: MiClase

5) lowerCamelCase: se usa para declarar variables primitivas o funciones o Objetos o Instancias. EJ: miVariable.

6) Ordenamiento del Codigo: Importacion de modulos, Declaracion de variables, Declaracion de Funciones y Ejecucion de Codigo.



                                                      2) Variables

1) Variable: Un lugar en la memoria donde se guardan datos.

2) var: Con var se declaraban las variables. El Problema es que al usar VAR en estructuras de control o bucles estas no tenian un SCOPE, 
es decir que estas no nacian y morian ahi mismo en esa estructura, sino que existian en un ambito global, un alcance total.

3) let: viene a solucionar el problema del SCOPE de var, esta si posee SCOPE y empieza y termina con las llaves{}

4) const: const basicamente se lo utiliza para declarar varibles constantes, que sabemos que su valor sera estatico en toda la ejecucion.
Tiene la peculiaridad que en Tipos de Datos compuestos no funciona igual, si declaro en un Array una series de valores yo despues le puedo
agregar mas elementos con push(), a pesar de que mi array sea const.
En sintesis, en Tipos de datos primitivos uso const en vez de LET cuando mi variable no va a cambiar su valor nunca, en tipos de datos 
compuestos usare const en vez de let cuando mi variable no mute hacia otra cosa(que pase de ser un arreglo a un objeto, un numbre etc).

5) Sintesis: no usar var porque es mala practica, no sirve para definir funciones en bloque ya que no se definen en el bloque sino antes
y pisa el valor que pueda tener en el ambito global. let viene a resolver estos problemas de var.

6) Objectos: Similar a C# un objeto son atributos con valores. let Persona = {nombre: "Pepe", edad: 35, sexo:"masculino};

7) Array: Es basicamente un conjunto de valores. let array = [1,2,3]

8) Window: Aqui es donde se almacenan todas las variables globales de JS.


                                                    3) Tipos de Datos

1) Primitivos: Apenas los creamos a estos objetos estamos accediendo a su valor. Tenemos: string, Number, boolean, null, undefined, NaN.

2) Compuestos: No accedemos directamente al valor sino a una referencia de donde esta el valor: 1) Object{}. 2) array[]. 3) function(){}.
               4) Class{}.
                                                    3.1) Primitivos

1) string: Es similar a los string de otros lenguajes, los puedo usar con "" o ''.

1.1) Atributos: 1) Length=>Me permite saber la cantidad de caracteres de la cadena, 

1.2) Metodos: 1) ToUpperCase&ToLowerCase()=> Me permiten setear todos las letras a Mayusculas o Minusculas. 2) Include()=> devuelve un 
              T/F si la cadena que le pase por parametro existe en la varible string que ejecuta la funcion. 3) trim()=> elimina los 
              espacios en blanco de los margenes. 4) split()=> esta funcion me permite generar un arreglo, por parametro le tengo que 
              pasar cual sera el caracter que separara cada elemento del array (si es por comas, puntos, espacios). 5) Slice(num)=> este
              metodo me permite seleccionar desde que posicion de la cadena de caracteres quiero seleccionar. 6) CharAt()=> a este 
              metodo le tengo que pasar la posicion del caracter que quiero extraer. 7) CharCodeAt()=> similar al anterior pero en vez
              de devolver el caracter devolvera su codigo. 8) concat() al igual que en SQL es para concatenar texto, tiene la particularidad,
              que si se lo asigno a un ARRAY concatenara sus valores. 9) endsWith()=> este metodo devuelve un T/F si la cadena termina con el
              parametro que le pase. Tambien le puedo pasar un parametro numerico que es la cantidad de caracteres a evaluar, en caso de que 
              quiera evaluar solo una parte y no toda la cadena.
              5.1) Slice(num1,num2): tiene una segunda funcion que es cuantos quiero caracteres quiero agarrar segun la posicion en la que 
              estoy.

1.3) Interpolacion-Strings: Interpolar es basicamente meter dentro de una cadena una variable. Para ello en JS deberemos usar Template-Strings
                            Para hacer la interpolacion deberemos usar ``, ya dentro de la cadena cuando queramos llamar a la variable para
                            colocarla dentro de la cadena lo haremos asi: ${variable}. Tambien esto me permite tener las cadenas con saltos
                            de linea.
EJ: let nombre = "Pepe Mujica"
    Console.Log(`Hola Soy ${nombre}`) // print: Hola soy Pepe Mujica

2) numbers: Son numeros, de todo tipo, no se diferencian ni por tamaÃ±o ni por decimales

2.1) Atributos:

2.2) Metodos: 1) ToFixed(1) => a este le tengo que pasar cuantos numeros decimales quiero que tenga mi numero. 
              2) Number.parseint(num) => me devulve solo el numero entero. Puede recibir un string, por lo cual puedo formatear un numero en 
              cadena de texto a entero numerico.  3) Number.parseFloat()=> lo mismo pero para valores flotantes. 4) Number.IsInteger()=>
              define si un numero es o no entero. 5) valueOf()=> me devuelve el valor de un number.

parseint o float no salen de la variable number debido a que estos pertenecen a la clase number, a diferencia de los otros metodos. Es 
decir que estos metodos dependen de un Constructor.

3) Booleans: es lo mismo de siempre

4) null: es un valor que solo el programador le puede asignar a la variable, a diferencia de otros lenguajes. Representa la ausencia de 
valor

5) undefined: Es una variable la cual no fue inicializada nunca. Representa la ausencia de valor.

6) NaN: Puede aparecer cuando queremos realizar operaciones aritmeticas con elementos que no son numeros.


                                                        3.2) Compuestos

1) ARRAYS: Un ARRAY basicamente es una coleccion de elementos, a diferencia de C# puedo coleccionar elementos de diferente tipo, incluyendo
objetos y otros ARRAY. Para acceder a la posicion del elemento de un ARRAY tengo que poner [numero].

const a = ["StringPicante", ["Elo", "Xd"]]
console.log(a[1][1] //Imprime Xd).

1.1) Propiedades Array: 1) Length.

1.2) Funciones Array: 1) ArrayOf()=> me permite declarar un array. 2) Array(lugares).fill(valores)=> me permite rellenar automaticamente 
todas los valores de un array. 3) push()=> me permite agregar elementos al array. 4) pop()=> Elimina el ultimo elemento.  
5) ForEach()=> Esta funcion me permitira pasarle un metodo el cual se ejecutara tantas veces como elementos haya en el array. Con el primer
valor recorreremos el valor del elemento y con el segundo parametro su posicion.

    arrayColores.forEach(function(item, posicion){
        Console.Log(item, "  ", "posicion");
    })


2) Objetos: Combiene declarar los objetos como CONST debido a que con esto nos evitamos de que este objeto cambie su referencia. Un objeto
es un conjunto de atributos y/o Metodos. Sus atributos pueden ser de cualquier tipo de dato ya sea complejo o simple. Tambien puede tener
metodos.

    const Persona = {
        nombre: "MaxiPijama",
        apellido: "Sar Fernandez",
        edad: 33,
        Habilidades: ["C#", "TS", "SQL"]
        Contacto:{Email:"Pijama@gmail", Numero: 353456, Pagina:"ElPentagono"}
        Saludar(){return "Holanda de 74"}
    }

3) THIS: Hace referencia a las variables o funciones que estan dentro de ese SCOPE. Si yo pongo dentro de mi objeto THIS voy a poder 
referenciar a todos los elementos que esten dentro de mi SCOPE.

DATO: Acceder al Valor por referencia: Lo que quiere decir esto es que para tener el valor de un elemento compuesto debo colocar el espacio
de la memoria al cual quiero acceder para rescatar cierto valor.

                                                        4) Funciones

1) Es un bloque de codigo independiente al bloque de codigo global. Las funciones tienen como tarea realizar una accion especifica. Pueden
tener parametros, pueden o no devolver un resultado. A diferencia de otros lenguajes en JS las funciones se consideran objetos. Las funciones
son de primera clase como en C# (Se pueden pasar como argumentos, retornar su valor a una asignacion). Estas se llaman funciones declaradas

        1.1) function FuncionDeclarada(){

        }

2) A diferencia de otros lenguajes no debo especificarle si es VOID o no ni el tipo de dato que va a retornar, si quiero devolver algo 
pongo un return y le adjunto el valor a devolver.

3) Parametros: En JS la funciones tambien permiten parametros, pero estos no tendra la declaracion de el tipo, solo pondremos el nombre
de las variables en la declaracion. Si llamo a la funcion sin los parametros no dara error pero los valores seran undefined. Tambien le 
puedo dar valores por defecto a mis parametros.

4) Funciones anonimas: Basicamente es crear una variable a la cual le voy a asignar el valor de una function. Esta variable normalmente
sera una CONST. Se lo llama funcion anonima debido a que la funcion no tiene nombre. A diferencia de las otras funciones yo a esta 
no la puedo llamar antes de declararla sino nos dara error. Estas Funciones Anonimas Expresadas son mejor practica que las clasicas 
funciones.

const FuncionExpresada = function(){return "Hola"} //

let variable= FuncionExpresada(); 
console.Log(variable); //"Hola"

                                                     5) Operadores Relacionales

1) >: Mayor a 
2) <: Menor a 
3) >=: Mayor o Igual a 
4) <=: Menor o Igual a 
5) ==: Son comparacion de valores, compara si los valores 2 elementos son iguales (Ignora su tipo de dato), mala practica.
6) ===: Compara tanto el valor como el tipo de dato, esta se usa al considerarse la buena practica.
7) !=:
8) !==:


                                                    6) Estructuras de Control 
                                                    
1) Estructuras de Control: Es el Mecanismo que permite controlar el flujo de ejecucion de la aplicacion. Segun resultados,acciones o 
X estimulos la programacion se ejecutara por distintos flujos. 1) Las Estructuras secuenciales son las estructuras con un solo flujo de 
ejecucion, una linea tras otra. 2) Las Estructuras condicionales Bifurcan el flujo, segun la condicion se cumpla o no se ejecutara un 
flujo u otro. (if, else if y else), (operador ternario) y (Switch) 3) Las Estructuras Repetitivas (For, While, Do While)

2) Ternario: let variable = (condicion que devuelve T/F) ? "Caso True" : "Caso False".`

3) ForIN: Esta me va a permitir recorrer/iterar las propiedades de un objeto, recorre el interiror de un objeto, su sintaxis en muy 
similar a un ForEach. Para acceder a los valores de la propiedad las debo colocar entre [""]. Se lo utiliza para objetos primitivos 
(No iterables)

    For(const prop in Persona)
    {
        Console.Log('Propiedad ${prop} Valor ${Persona[prop]}')
    }

4) ForOf: Es Basicamente un ForEach, me permite recorrer un ARRAY o cadenas, basicamente listas. Se lo utiliza para objetos Iterables.

                                                        7) Manejo de Errores

1) Funciona con el Clasico Try-Catch-Finally.

2) throw: Sirve para lanzar la excepcion, el por defecto es ERROR.

                                                        8) Break y Continue

1) Break lo que hace basicamente es terminar con la ejecucion de un Ciclo o de un Switch.

2) Continue: Se salta la vuelta del ciclo en la que se ejecute.

                                                        9) Destructuring

1) Destructuring: Es una nueva forma de asignar valor a arreglos y objetos en JS. Esto es para ahorrar lineas de codigo en la asignacion
                  En el caso de los objetos para que la destructuracion funcione necesito que el nombre de la variable sea igual al nombre 
                  del atributo del cual quiero extraer el valor, sino cumplo esto mi variable sera undefined.

                  const array = [1,2,3]
                  let [PrimerElemento, Segundo, Tercero] = array 

                  const Persona = {nombre: "Hernan", apellido: "Pastrami", edad: 33}
                  let {nombre, apellido,edad} = Persona

                                                        10) Objetos Literales

1) Los objetos literales son basicamente una nueva forma de escribir atributos y Metodos. En el caso de los atributos si ya tengo atributos
con el mismo nombre de mi propiedad JS entendera que quiero tomar esos valores asi que los asignara automaticamente.

       let nombre = "Pipo",
       let Apellido = "Argenti";

        const JugadorRacing = {
        nombre,
        Apellido
        }   

                                                11) Parametros REST y Operador SPREAD

1) Parametros REST: Se utiliza en los casos de que no se cuantos valores o parametros voy a recibir o tener en un arreglo. A este
parametro se lo Representa con "...". Por Ejemplo en el caso de sumar numeros cuando no se cuantos numeros sumar puedo usar parametros
REST. Para esto al parametro REST lo vamos a tratar como un ARRAY, ya al no saber cuantos valores son lo vamos a usar como un ARRAY. El
Parametro REST solo se ejecuta en los parametros de una funcion.

    function Sumar(a,b, ...c){
        let resultado = a+b;

        c.forEach(function(numero){
            resultado+=numero;
        })
    }

2) Operador SPREAD (operador de propagacion): Con el SPREAD puedo concatenar ARRAYS/OBJETOS y puedo crear copias exactas de los objetos, 
una copia con su propia referencia.

        const array3 = [...array1, ...array2]
        const objeto3 ={
            ...objeto1,
            ...objeto2
        }


                                                        12) ARROWS FUNCTIONS

1) Son una nueva forma de definir funciones anonimas Expresadas (const FuncionExp = function (){}). La sintaxis es la siguiente:
    const ArrowFunction = ()=>{}

2) En el caso de que no tenga parametros la ARROW_FUNCTION deberemos colocar parentesis, si tiene un parametro no hara falta.
   const FuncionExp = nombre => {}
   FuncionExp("Generico");

3) Tambien en su escritura si solo tiene una sola linea de codigo esta realizara un return implicito.

4) Declarar Metodos dentro de objetos literales con ARROW_FUNCTION puede ser un problema debido que al declarlo si yo uso THIS no apuntare
dentro del objeto sino que apuntare hacia el ambito global. Esto es porque las ARROW_FUNCTION apuntan hacia el contexto en el cual se 
encuentra su objeto padre. En sintesis es de mala practica crear ARROW_FUNCTION dentro de objetos literales.


                                                        13) Prototipos

1) Prototype: Es una propiedad que tienen todos los elementos de JS. El Prototipo es un objeto que funciona como una plantilla que proporciona
metodos y propiedades que el objeto puede usar.

1.1) La razon de la existencia de prototype es que los objetos puedan heredar caracteristicas entre si, lo cual es util cuando quiero
que varios objetos compartan metodos y/o propiedades.

2) Las clases de JS en momento de compilacion transforman las CLASES a Funciones Prototipales, porque la POO de JS se encarga mas del Manejo
de prototipos que el manejo de CLASES. Este solo simula un manejo de clases en su sintaxis, pero realmente  maneja prototipos.

3) Para Construir un prototipo yo puedo hacer uso de una funcion constructura. Para que la funcion constructura funcione debo colocarle
tanto a sus metodos como propiedades la palabra THIS.

    function Constructora(nombre, edad){
        this.nombre = nombre;
        this.edad = edad;
    }

4) Para llamar a la funcion constructora deberemos llamarla con NEW: const persona = new Constructora("Jose", 33);

5) Por temas de rendimiento en los prototipos no se suelen colocar metodos, sino solo los atributos. Para agregar metodos a un prototipo lo
que hago es llamar a la funcion constructora, a la propiedad prototype  y agregar la declaracion de la funcion. Basicamente los metodos
no se lo agregamos a las instancias de los objetos sino al prototipo de este. Esto es la herencia Prototipica.

    Constructora.prototype.Hablar = function (){};

6) A partir de las clases a nosotros ya no nos hace falta construir estos prototipos, solo necesitamos crear las Clases y JS al compilar
creara estos constructores de prototipo por nosotros.

                                                        14) Herencia Prototipica

1) function Perro(nombre, edad, tamanio){
    this.super = Animal;        //IGUALO SUPER AL PROTOTIPO ANIMAL
    this.super(nombre, edad);   // PASO PROPS DEL Constructor ANIMAL.
    this.tamanio = tamanio;
}
Perro.prototype = new Animal();
Perro.prototype.constructor = Perro;

En el bloque de la funcion estoy definiendo de donde va a sacar sus atributos perro, en este caso le creamos una clase super que heredara
de un objeto Animal, esta clase determinara su nombre y edad, y luego ponemos su prop de tamanio como hacemos normalmente, ahora para 
completar la herencia le debo pasar a perro ese objeto Animal, esto para que el prototipo de perro herede todas las caracteristicas del
prototipo animal, por eso es que sin ello no se completa la herencia.

2) Polimorfismo Prototipo: Perro.prototype.Sonido = function () {}

Sintesis: Super se convierte en la funcion constructora de animal la cual le pasa tanto nombre como edad, luego termina de colocar tamanio.
Con esto ya se heredo los atributos, pero no los metodos, para esto decimos que el prototype de Perro es el de Animal, con esto heredamos
las propiedades.


SINTESIS PROTOTIPO: Es una especie de auxiliar, en el puede tener atributos y/o propiedades que las puede reutilizar una clase, solo 
llamando a su prototipo. Para heredar el prototipo de una clase es tan sencillo con hacer un new CLASE();

                                                    15) Clases y Herencia

1) Las clases lo que hacen basicamente es simplificarnos la escritura, al final por detras todo funciona con prototipos y no clases,
pero las clases nos simplifican la forma en que declaramos objetos, heredamos y construimos prototipos. 

class Animal{
    constructor(nombre, edad)
    {
        this.nombre = nombre,
        this.edad = edad
    }

    Sonido(){
        Console.Log("Hola Papu")
    }
}

2) Para realizar la herencia es tan simple como utilizar la palabra reservada extends. Luego en el constructor le tengo que pasar todos 
los parametros que reciba su constructor. Los parametros que sean configurados de su padre los pondremos en super(), en los otros seguiremos
el modelo this.

class Perro extends Animal{
    constructor(nombre, edad, raza)
    {
        super(nombre, edad);
        this.raza = raza;
    }

    Sonido(){
        Console.Log("Viva Peron")
    }
}
                                         16) Metodos Estaticos, Getters y Setters

1) En JS no existen las clases privadas, por ende todas las clases son public.

2) Si existen los metodos Static, pero funcionan un poco distinto, puedo volver a un Metodo Static sin la necesidad de volver a mis clase
Static. Luego el llamado es igual. Como Dato las clases Static no aparecen en los prototipos.

class Prueba{
    static Saludo(){
        Console.Log("Hola")
    }
}

Prueba.Saludo();

3) A diferencia de C# yo debo crear Metodos GETERS y SETERS. El Metodo Get lo unico que suele hacer es un Return a la propiedad que quiero
recuperar. En los Seters se recibira un parametro que sera el valor de mi propiedad. Para indicar que no son metodos comunes le antepondremos
las palabras get y set respectivamente.

class Persona
{
    constructor(nombre, apellido)
    {
        this.apellido = apellido;
        this.nombre = nombre;
        this.edad = null;

        get GetEdad()
        {
            return this.edad;
        }

        set SetEdad(edad)
        {
            this.edad = edad;
        }
    }
}

3.1) Para tener en cuenta que estas funciones GET y SET en tiempo de ejecucion las transforma en propiedades/atributos y no metodos, por
ende la debo tratar como tal.

let edad = persona.GetEdad;
persona.SetEdad = 33;


                                                        17) Objeto Console

1) .Log: Me permite enviar mensajes a la consola. 2) .Error: Me permite enviar errores a la consola. 3) .warn: Me permite enviar warnings.
4) .Info: Para un mensaje informativo. 5) .Clear: Limpia la consola. 6) .dir: Me permite mostrar por consola un elemento en formato objeto.
7) .Group: Me permitira crear grupos de mensajes por consola, todos los consoles log por debajo perteneceran al grupo hasta que lo 
corte un .GroupEnd. 8) .table: Me permite leer un elemento en forma de tabla. 9) .time: Me permite saber el tiempo que tarda en realizarse
una peticion, este para al llamar al console.timeEnd(). 10) .count: Cuanta cuantas veces se ejecuto un bloque de codigo.
11) .Assert: Me permite hacer prueba unitarias, pasandole una condicion y los valores a evaluar por array.

console.Assert(x<y,[x,y,"Error, X debe ser menor a Y"])


                                                        18) Objeto Date

1) Es el objeto base de las fechas, es el equivalente a DateTime. Si creo un objeto de DATE puedo acceder a sus Metodos.

2) Metodos: 1) GetDate(): Me permite extraer el dia del mes en formato number. 2) GetDay(): Me permite extraer el dia de la semana en formato 
number (D-0, L-1, M-2, M-3, J-4, V-5, S-6). 3) GetMonth(): Me permite obtener el mes en formato number, esto cuenta del 0 al 11.
4) GetFullYear(): Me permite obtner el aÃ±o en formato number. 5) GetHours(): Obtengo la hora en formato number. 
6) getMinutes(): Obtengo los minutos en formato number. 7) getSeconds: obtengo los segundo en formato number. 8) getMilisegundos(). 
9) toDateString(): Me permite obtener la fecha (dia de la semana, Mes, dia numerico de mes y aÃ±o) en forma de cadena de texto.
10) toLocaleString(): la forma mas clasica de representar la fecha. D/M/Y h:m:s. 11) toLocaleDateString: d/m/y. 
12) toLocaleTimeString: h/m/s. 13) Date.now(): Muestra numericamente cuantos segundos pasaron desde 1970, se lo conoce como timeStamp.
14) getTime(): Me permite obtener el timeStamp de una fecha.

Moment.JS => Libreria para manejar el tiempo.

                                                      19) Objeto Math

1) .ABS(): Me devuelve el valor absoluto de un numero. 2) .CEIL(num): Redondea para arriba. 3) .FLOOR(num): Redondea Hacia abajo. 
4) .ROUND(num): Redondea al mas cercano. 5) Sqrt(num): Me permite sacar la raiz cuadrada de un numero. 6) POW(num1,num2) Me permite elevar
el numero a alguna potencia, num1 sera la base y num2 la potencia. 7) .Sign():Evalua si un numero es positivo, negativo o cero. 
8) .Random(): Me devolvera un Numero Random entre 0 y 1 console.log((Math.random()*1000).toFixed(0));

                                                    20) Operador CortoCircuito

1) CortoCircuito OR: Cuand el valor de la izquierda en la expresion siempre pueda validar true, es el  valor que se cargara por defecto.
es decir que si el valor de la izquierda no es undefined se cargara ese valor.

function Saludar(nombre){
    nombre = nombre || "Desconocido";
    console.log(`Hola ${nombre}`)
}
En este caso si nombre no tiene un valor definido nombre se cargara con el valor de Desconocido, si tiene un valor lo mantendra. Los 
valores false, null, undefined, "" y 0 seran los que haran que se elija la opcion de la derecha.

2) CortoCircuito AND: Cuando el valor de la izquierda en la expresion siempre valide false, es el valor que se cargara por defecto, es el
opuesto al CortoCircuito de OR.

SINTESIS: Cuando la opcion de la izquierda tienda a TRUE devolvera la opcion de la izquierda en el Operador OR. Cuando la opcion de la 
izquieda tienda a false esta devolvera la de la izquierda cuando usemos el operador AND.

                                                  21) Alert, Confirm y Prompt

1) Estos metodos vienen del objeto padre Window. Estos 3 metodos me permitiran interactuar con el usuarios.

2) Alert: me permite mandar un mensaje de alerta al usuario, solo tiene la opcion de aceptar. No es necesario guardar esta en una variable,
ya que su resultado siempre sera undefined.

3) Confirm: Manda un mensaje al usuario con las opciones de aceptar o cancelar. Si la guardo en una Variable depende cual boton toque 
esta devolvera un T/F.

4) Prompt: Manda un mensaje al usuario y le permite ingresar un valor. Al guardarla en una variable guardara el valor que le coloquemos
en el input, en el caso de que apretemos aceptar. Si presionamos cancelar devolvera null.

                                                    22) Expresiones Regulares

1) Expresion Regular: No es mas que una secuencia de caracteres que forman un patron de busqueda de cadena de texto. Tambien se las conoce
como Regex. Me sirve para validar formatos de texto, por Ejemplo mails, contraseÃ±as con X reglas o exclusiones de caracteres.

2) Declaracion: 1) let regex = new RegExp("","flags"); 2) let regex = /regex/

3) Metodos: 1) test(): Verifica si la cadena que le pase cumple con el regex, devuelve T/F. 2) exec: Este devuelve un arreglo con la palabra
buscada, la posicion en la que se encontro y la cadena completa.

4) Comodines: Son determinadas reglas que le agregaremos al patron REGEX. 1) i: ignora mayusculas y minusculas. 2) g: busca todos los 
elementos que matcheen no se queda con el primero. 3) \d: valores Numericos. 4) \D: Valores NO numericos. 5)

                                            23) Funciones Anonimas AutoEjecutables

1) Estas son un patron de diseÃ±o, luego de ser declaradas estas funciones procederan a ejecutarse. Estas pueden ejecutar funciones 
asincronicas o limpiar el entorno global. Estas obligatoriamente necesitan de un punto y Coma.

2) Sintaxis: (function (d,w,c) {//Codigo})(document, window, console);

                                                        24) Modulos

1) Los modulos vienen a reemplazar las Funciones Anonimas AutoEjecutables. Lo que hacen los modulos es llamar un archivo de JS dentro 
de un archivo JS.

2) Para poder realizar importaciones de modulos en JS debo declarar mi script de JS  en HTML y agregarle el atributo type="module"
   <script src="js/modulos.js" type="module"></script>

3) Exportar Variables: export const Pi = Math.PI;__Sin la palabra reservada export la variable no se podra exportar hacia el modulo de JS
   Exportar funciones: export function restar(a,b) { return a-b}
   Exportar Objetos: export const aritmetica = {Sumar(a,b){return a+b}, Restar(a,b){return a-b}}

3.1) Exportar Default: export Default Sumar(a,b){return a+b}; Solo puedo tener un elemento exportado por Default.

4) Importar: Import {Pi} from "./miarchivo.js"; Import {restar,sumar, aritmetica} from "./aritmetica.js";

4.1) Importar Default: Import Sumar,{restar} from "./aritmetica.js"

5) Export Default variables: Para hacer un export default de una variable deberemos hacerlo luego de su declaracion. 
                   EJ: const nombre = "Pepe";
                       export default nombre;

6) Alias: Import {Pi as numeroPi} from "./miarchivo.js";


                                              25) Datos Practicos de los ejercicios

1) typeof: me permite evaluar el tipo de una variable. If(typeof cadena == 'string') 

1.1) Otra forma es hacer:  if(cadena.constructor === String)

2).: Tiene 2 funciones, la que recibe un parametro me permite decir en que posicion de la cadena quiero comenzar. La que recibe 2
paramtros me permite decidir tanto desde que posicion empezar y cuantos caracteres quiero agarrar desde esa posicion.

3) Operador ternario dentro de operador ternario: const aux = (x>y)? "Es Imposible": (x!=33)? "Enserio?": "Sabe Cosas"

4) Join(): Metodo de ARRAY que me permite juntar todos los elementos de ARRAY con separadores personalizados.

5) Split(): Si no le paso ningun caracter esta separara todos los caracteres en elementos de un arreglo.

6) "": tiende a falso

7) IndexOf(palabra, Comienzo): Este metodo se usa para cadenas de texto, si encuentra la palabra que le pasamos por parametro devolvera el
index de la primera letra de la palabra, si no encuntra la palabra devuelve -1. Tambien le puedo pasar un segundo parametro, este definira
desde que parte de la cadena quiero evaluar.

8) 1) Con esto construyo una fecha. 2) Declaro un objeto tipo Date. 3) Calculo la fecha, debo convertirlos a timeStamp con getTime(). 
   4) Construyo una nueva fecha con el resultado timeStamp. 5) Imprimo pero restando 1970 ya que es el aÃ±o base donde comienza el 
   timeStamp.

    1) const fecha = new Date(y,m-1,d);
    2) let fa = new Date();   
    3) fa = (fa.GetTime() - fecha.GetTime());
    4) const resultado = new Date(fa);
    5) console.log(resultado.getFullYear()-1970)

9) InstanceOf: Es igual que el typeof pero para variables compuestas.
               if(!fecha instanceof Date) return console.warn("Coloque una fecha valida");

10) RegExp Mail: /[a-z0-9]+(\.[_a-z0-9]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,15})/i

11) map(): Me permite acceder a todos los elementos del array y manipularlos, y de paso esto se lo puedo asignar a un array nuevo
const newArray = array.Map(el=>el*el);

12) Ordenar Array Numerico: array.sort((a,b)=>b-a)

13) SET: Set es un elemento que me permite construir un array nuevo en el cual no se permitiran elementos duplidos. La Naturaleza del
set es generar elementos sin duplicaciones.
         [...new Set(array)]

14) const prom = array.reduce((acu, item)=>{return acu = acu + item},0);

15) Cuando JavaScript intenta convertir un objeto a una cadena, obtienes [object Object]. Para solucionar esto, puedes convertir el 
objeto a una cadena JSON utilizando JSON.stringify().

16) Filter(): Con filter puedo hacer varias funciones, una de ellas es comparar elementos con todo el array:
                Filter((value, index,self)=>self.IndexOf(value)===index)

Lo que hago aca basicamente es con filter construir un nuevo arreglo, value extrae los valores del array, index las posiciones y self el
array original. Luego lo que hago es construir el array con los indices del array viejo. Aca esta la clave lo que hago es que voy a buscar
el index de todos los valores del array original y lo voy a comparar con el index para ver si existe. El truco para evitar repetidos es
el IndexOf, ya que este buscara siempre el indice del primer elemento que encuentre, si esta repetido se quedara con el  array del que 
este mas cerca, de esta forma cuando venga un dato repetido solo pisara el anterior pero nunca se colocaran 2 elementos repetidos gracias 
al IndexOf().

17) Array.Includes(): me permite ver si los elementos de un array existen en otro Array. Devuelve un T/F.

 for(let item of array)
 {
    array2.incluedes(item);
 }

                                             II) Programacion Asincrona


                                                26) Temporizadores

1) SetTimeOut: Este recibe una CallBack (una funcion como argumento) y una declaracion en MiliSegundos de del tiempo que es
en cuanto tiempo se debera ejecutar la CallBack.
setTimeout(()=>{
 console.log("Hola")
}, 5000)

1.1) El cancelador del SetTimeOut es el ClearTimeOut(setTimeout), para esto debo guardar mi setTimeOut en una variable y pasarle esa
variable al ClearTimeOut.  

2) SetInterval: Es un igual que el SetTimeOut solo que este se ejecuta segun el intervalo de tiempo que le establezcamos.
setInterval(() => {
    console.log("Copy")
}, 1500);

2.1) El cancelador del SetInterval es el clearInterval(), funciona igual al ClearTimeOut.

                                                27) Asincronia y EVENT LOOP

1) La Asincronia es uno de los pilares principales de JS, ya que JS es un lenguaje que solo trabaja con un hilo, por ende solo puede 
ejecutar una cosa a la vez.

2) EVENT-LOOP: El EVENT LOOP basicamente es la forma en la que tiene JS de ejecutar sus tareas. Aquellas funciones o metodos que dependan
de APIS externas seran las ultimas en ser llamadas ya que el EVENT LOOP primero se encarga de ejecutar todo lo que tenga el SCRIPT principal
y luego lo provenientes por APIS externas, es decir el EVENT LOOP ejecuta el script principal y almacena las peticiones de APIS externas, 
(TASKS) cuando termina el flujo principal procesa las TASK/APIS.

3) Macro-Task: Son las tareas que tienen su propia pila de ejecucion y un elevado consumo de memoria. Esta es el SCRIPT principal o alguna
api que generemos con SetTimeOut(). 3.1) Micro-Task: Las promesas son pequeÃ±as tareas que se ejecutaran luego terminado la Macro-Task 
principal.

5) Operaciones I/O: Son operaciones de entrada y salida, ante la entrada de datos se devolvera una respuesta. El proceso es el ABC de la 
programacion, el usuario introduce datos, el programa lo procesa  y segun lo que procese devuelve datos. Estas son las que mas se ejecutan 
en JS.

6) Operaciones Concurrentes: Es cuando 2 o mas tareas progresan simultaneamente. La diferencia con la paralela es que puede ser que una 
de estas tareas que progresan a la vez no necesariamente comenzaron a vez a diferencia. 7) Operaciones Paralelas: Es cuando 2 tareas se 
inician al mismo tiempo y se ejecutan a la par.

8) Operacion Bloqueante: Son aquellas que bloquean el hilo de ejecucion en la espera de termino de un proceso (sincrono).8.1) Lo opuesto 
son las no Bloqueantes que durante la espera deja que el Hilo de Ejecucion se libere y realice otras tareas (Asincrono).

9) Operacion SYNC/ASYNC: Se diferencia por cuando tendra la respuesta, si es en el inmediato es sincrono, si no se sabe cuando se tendra
la respuesta es Asincrono, la ASYNC no espera el resultado y suelta el hilo hasta que el resultado sea devuelto.

10) Codigo en JS: El codigo de JS sera Single-Thread, de operaciones I/O y: 1) Codigo Sincrono Bloqueante. 2) Codigo Asincrono 
No-Bloqueante.

11) SINTESIS EVENT LOOP: JS funciona con un solo hilo de ejecucion y con operaciones de I/O. La ejecucion de las tareas asyncrona es la 
siguiente: 1) En mi stack principal voy llamando las tareas, aquellas de indole asincrona de Espera se van hacia el modulo de Web APIS
y se realiza su espera pero liberando el hilo, una vez estas terminan de ejecutarse van a la cola de espera de las CALLBACKS. Cuando 
termina de ejecutarse el hilo principal de la aplicacion el EVENT LOOP busca aquellas funciones que hayan quedado en la cola de las 
callback y las ejecuta.


                                                        28) CallBacks

1) CallBack: Una CallBack basicamente es una funcion que se pasa como argumento a una funcion y luego se le utiliza o se la re-llama dentro
de la ejecucion del codigo. Cuando declaro la funcion como argumento no se ejecuta, sino que solo la declaro, luego en el codigo de la 
funcion la llamare.

// DECLARO CALLBACKS
const CallBack = (array,rellamda) =>{
    array.push("El Papu");
    rellamda(array);
}
//LLAMO LA FUNCION Y DECLARO EL CALLBACK
CallBack(names, (array)=>{
    console.log(`Se agrego un elemento: ${array.reverse()[0]}`)
})

2) Los CALLBACKS tambien son uno de los mecanismos que nos da JS para trabajar con asyncrona, el problema que presenta esta es el callback
Hell que es la llamada de muchos callback lo que genere un codigo poco legible.

3) Control Async: Estos Callback me permiten ejecutar los procesos de forma ordenada al anidar CALLBACKS dentro de callbacks, lo ejecucion
sera en el orden de anidamiento. El motivo de esto es debido a que al anidar callbacks estoy pidiendo que se complete la primera operacion
asincrona antes de que se ejecute la anidada. EstÃ¡s creando una dependencia entre las operaciones asÃ­ncronas, donde la segunda operaciÃ³n no 
puede comenzar hasta que se complete la primera.

CallBack(names, (names)=> {
    console.log(names[0])
    CallBack(names, (names)=> {
        console.log(names[1])
        CallBack(names, (names)=> {
            console.log(names[2])
            CallBack(names, (names)=> {
                console.log(names[3])
            })
        })
    })
})

                                                          29) Promesas

1) Una Promesa es una especie de IF-ELSE, donde si la promesa se cumple se ejecutaria el Bloque RESOLVE, sino el REJECT. Las promesas 
reciben 2 funciones que son el RESOLVE y el REJECT. Estas Vienen a reemplazar a las CALLBACKS ASYNC.

2) Dentro de la PROMISE ira todo nuestro codigo, en este colocaremos el RESOLVE en el lugar donde veamos que se cumplen correctamente la 
accion. En los parentesis del resolve ira lo que queramos devolver de nuestra promesa

const Promesa = (array) =>{
    return new Promise((resolve, reject)=>{
        setTimeout(() => {
            resolve(array);
        }, Math.random()* 1000);
    }) 
}

3) Metodos para Trabajar la ASYNC con PROMISE: 1) THEN():  Este recibira el resultado del Bloque RESOLVE(). Dentro de sus parametros le 
pasaremos un CALLBACK con el cual podremos manipular el resultado del RESOLVE. Tambien en esta callback de THEN puedo retornar el elemento
y pasarselo a un THEN() para que lo manipule. Con Esto tambien tengo la ventaja de que cada then() se ejecutara al termino del anterior.
2) CATCH(): Este se encargara de capturar el error que devuelva el bloque REJECT, la ventaja de esto es tener una sola validacion para 
todas las promesas.

3.1) Promesa(names)
     .then((array) => {console.log(array[0])}
            return array;)
     .then((array)=> {console.log(array[1])}
          console.log("END"));

3.2) Promesa(names)
     .then((array) => {console.log(array[0])}
            return array;)
     .Catch(err => console.error())

4) SINTESIS: Las promesas son ASYNC debido a que la ejecucion de estas puede que tenga periodos de espera, es por ello que ante algun evento
que genere una espera la PROMISE permite la liberacion del HILO de ejecucion para otras tareas, cuando la promesa se termine con el bloque
RESOLVE o REJECT esto va hacia la cola de CALLBACKS y ahi lo recoje el EVENT LOOP. Con el THEN() Manipulo el objeto que devolvio la promesa
y puedo manipularlo en varios THEN(), el CATCH() en para el error.

                                                     30) Async - Await 

1) Esto tambien me permite trabajar con Asincronia, aunque no viene a reemplazar las promesas sino las complementa. Para manejar los errores
de funciones ASYNC usamos TRY-CATCH.

async function funcion(){}

2) Al igual que en C# para aquellas acciones asincronas yo debo colocar AWAIT, debido a que esta ademas de liberar el hilo de ejecucion
parara la ejecucion de esa funcion, porque sino la funcion Asincrona esperara resultados de la API pero mi funcion principal nunca
paro a esperar los resultados y siguio de largo.

async function funcion(){
    Try{
    let nombres = Await NombresBD(); => NombresBD() Maneja Promises.
    return console.log(nombres);
    }
    Catch(error)
    {
        console.error(error) 
    }
}

const funcion = async () =>{}

3) Esto me permite ahorrarme la concatenacion de THEN(), basicamente las funciones ASYNC me permiten Emprolijar la sintaxis de las 
promesas, pero no las reemplazan.

DATO ASYNC: Async no es solo liberar el HILO de ejecucion sino que tambien es la capacidad de parar la ejecucion lineal de la funcion, 
la pausas hasta que tu proceso ASYNC se complete.


4) SINTESIS ASYNC : 1) Los Callbacks ya no se usan por tema de legibilidad. Cuando estos utilizan un setTimeOut() el stack de compilacion 
de JS lo envia a la pila de WEB API (maneja las tareas ASYNC, las de larga duracion) una vez terminada va a la cola de Callbacks y ahi
la rescata el EVENTLOOP. Al concatenar Callbacks me permite ejecutar ordendamente y asincronamente tareas. 2) Las Promesas al igual que 
los Callbacks al utilizar alguna operacion asincrona (solicitudes de red, lectura de archivos, APIS, setTimeOut) pasara a la cola de las
WEB API y esperara el cumplimiento de las promesas para pasar a la cola de CALLBACKS. En THEN() generaremos un CALLBACK donde
manipularemos el resultado del RESOLVE(). 3) Las funciones ASYNC son una forma de mejorar la escritura de las promesas, la declaracion
del RESOLVE y el CATCH es igual, solo que al llamar la funcion con la promesa le colocaremos la palabra AWAIT para que aguarde la ejecucion
y libere el HILO, puedo guardar el resultado en una varible si necesito conservar y manipular el objeto. 

4.1) Las Promesas con THEN() liberan el hilo pero no paran la ejecucion del flujo, AWAIT si.

LAMBDAS: Parece que las ARROW_FUNCTION y las LAMBDAS de C# son casi iguales. Las LAMBDAS me permiten declarar funciones anonimas de un 
parametro con un Return implicito.

                                                        31) Symbols

1) Es un nuevo tipo de dato de JS, este es un tipo de dato primitivo (string, number, bool). Una vez que definimos Symbol su valor se va
a mantener privado para uso interno, generalmente son propiedades que se les otorga a los objetos.

2) Symbol nos permite crear identificadores unicos y de referencia (ids). Yo le puedo asignar un nombre a estos symbols para identificarlos
pero cada uno de estos sera unico, aunque tengan el mismo estado(la misma informacion) seran elementos diferentes ya que seran objetos distintos
con el mismo estado.

3) Para declarar una propiedad de un objeto privada con symbol le colocamos [] al nombre de la prop. Si yo creo una PROP del mismo nombre 
del SYMBOL no habra problemas.


4) Para llamar a una PROP symbol debo llamarla mediante corchetes, esto me devolvera el valor de la etiqueta del SYMBOL.
Console.log(persona[ID]);

5) SINTESIS: Es un tipo de dato primitivo que me sirve para colocarle especie de propiedades privadas a objetos, decimos que es privada 
porque no es accesible por ningun metodo que no conozca el valor del nombre de la propiedad symbol ([sym]), por ende ninguna iteracion 
podra acceder a el, solo nosotros si lo especificamos manualmente. Tambien puedo crear funciones. Eso si antes de asignar un Symbol a 
un Objeto debo crearlo con el mismo nombre. Cada Symbol sera un objeto unico aunque tenga el mismo estado.

const ID = Symbol();
const Saludar = Symbol();
const obj = {
    [ID]:"Secreto",
    [Saludar](){
        console.log("Hola")
    }
}
obj[Saludar]();

                                                            32) Sets

1) Es una estructura similar a un array pero, no permite Datos repetidos, es decir un elemento que simula ser un array que almacena datos 
unicos.
Const Array = new Set([1,2,3,5,3]) // console.log(Array); //Imprime [1,2,3,5]

1.2) Metodos: 1).Add(): Con Este metodo le puedo agregar nuevos elementos al SET. 2) .forEach(). 3) .Delete(): Tengo que pasarle el 
valor exacto del elemento que quiero borrar. 4) .has(): va a comprobar si el valor que le pase existe o no en el set, devolviendo un 
T/F. 5) Clear(): Elimina todos los elementos del SET

2) El tamaÃ±o de este SET lo puedo ver mediante su propiedad size (es lo mismo que Length)

3) SET no es un arreglo como tal sino que simula ser uno, cuando quiera acceder a sus valores no lo puedo hacer con set[0] porque 
devolvera un undefined. Para poder utilizarlo como Array utilizo el metodo Array.from(set[0])

                                                            33) Maps

1) Maps son objetos que almacenan valores asociados a manera de objeto, es como un objeto primitivo. Tienen la caracteristica de trabajan
mucho con GETERS y SETERS. Me permite crear propiedades y manipularlas atraves de sus funciones nativas de GET y SET.

const obj = new Map();
obj.set("Name", "Pepe");
console.log(obj.get("Name"))
const map = new Map([
    ["nombre", "Fer"],
    ["Edad", 33],
    ["Amigo", ["Antonio", "Pedro"]]
])

2) Tiene la caracteristica de que puede ser recorrido como un objeto iterable por un forEach(), a diferencia de los objetos clasicos.

3) Los nombre de las propiedades de los Maps(llamadas Keys) pueden ser cualquier cosa (numeros, objetos, arrays), mientras que los 
objetos comunes solo se puede poner de nombre de props string o symbols.

4) Se recomienda usar maps en el caso de que deba aÃ±adir y borrar propiedades de manera intensiva ya que tienen un mejor rendimiento que 
los objetos.

5) Sintensis: Los MAPS basicamente son una evolucion del objeto primitivo comun, en el cual se implementan pequeÃ±as funciones (get, set,
delete, forEach, size, clear, has) y flexibilidades a la hora de declarar las props, pudiendo colocar el nombre de la prop (keys el valor 
que quiera), ademas se vuelve un objeto iterable.

                                                       34) WeakSets y WeakMaps

1) WeakSet: Deriva de los Set, solo acepta objetos, no podemos iterar en ellos, se pierden varias funciones propias de los SETS, solo 
se conserva add(), delete() y has(). Tambien no puedo asignarle los valores en su funcion constructora, sino con add() uno a uno.

2) WeakMaps: Deriva de maps y solo acepta objetos como valores. No es iterable y solo conserva las funciones get(), set(), has() 
y delete()

3) La ventaja que tienen estos Weak es que cuando a alguno de sus elementos que la componen se vuelven nulls o undefined se eliminan 
directamente estos objetos sin la necesidad de esperar al Garbage Collector.

                                                      35) Iterables & Iteradores

1) Cuando decimos que una variable o elementos es iterable significa que es una estructura de datos lineal que hace que sus elementos sean
publicos, es decir que se puedan recorrer sus elementos mediante ciclos. Ejemplo de Elementos Iterables son: 1) Nodos del DOM, 2) cadenas
de texto. 3) Arrays. 4) Maps. 5) Set.

2) Un iterador es un apuntador que va recorriendo los elementos "items" de esa estructura de datos iterable.

1.1) Iterable: Elemento el cual puede ser recorrido mediante un iterador(ciclo).

2.1) Iterador: Un apuntador que va a recorrer la estrutura de datos de un elemento iterable, se los conoce como ciclos. 

3) Iteradores: 1) FOR. 2) FOR OF. 3) ForEach. 4) Destructuracion. 5) Array.From(). 6) Map(). 7) Filter(). 8) Reduce(). 9) SpreadOperator.



                                                        36) Generators

1) Los Generators son una forma mas sencilla sintacticamente de generar iteradores. Para definir que va a ser un generador lo debo 
hacer de la siguiente forma. Con el "*" accedo al Symbol.iterator

2) Generador: Un Generador es basicamente convertir el codigo de una funcion en un Iterador mediante los YIELD. Para ejecutarlo la 
guardaremos en una variable y lo recorreremos con un FOR OF o con NEXT()

3) YIELD: Es un Return que una vez que salta la proxima vez que se ejecute la funcion se ejecutara justo en la linea que este por debajo
del YIELD que hizo saltar a la funcion, ya que YIELD detiene la ejecucion de la funcion.

4) Lo interesante de las funciones generadoras es que por cada  yield me va a devolver diferentes datos, ya que siempre va a ir 
a un YIELD diferente.

function* Iterador(){
    console.log("Inicio")
    yield 1;
    yield 2;
    yield 3;
    console.log("Fin")
}
const iterador = Iterador();
for (let yield of iterador) {
    console.log(yield)
}

                                                      37) PROXIES

1) Es un nuevo mecanismo de JS que te permite crear un objeto basado en un objeto literal inicial, en donde el objeto original puede 
ser accedido solo mediante el proxy, por eso decimos que el proxy es un intermediario de objetos, ya que para acceder al objeto original
lo haremos mediante el proxy. Es util ya que con este podremos validar datos, ocultar propiedades e interceptar llamadas de funciones.

1.1) Si quiero realizar una modificacion sobre el objeto debere interactuar con el Proxy y este me debera validar si la modificacion
es o no OK, si yo quiero modificar el objeto debo configurarle el SET con sus validaciones, sino el proxy no me dejara configurar el 
objeto.

1.2) El objeto Proxy recibira 2 elementos en su funcion Constructora: 1) El objeto literal al cual va a intermediar. 2) Handler: Este 
tambien debera ser un objeto, dentro de este deberemos crear la funcion SET(), esta se encargara de realizar las validaciones que le 
definamos. Es decir que Handler se encargara de realizar las validaciones a los datos que le cargue al objeto.

1.3) El Set() de Handler recibira 3 parametros: 1) El Objeto literal. 2) La Propiedad de ese objeto a verificar (pueden ser mas de una).
3) El Valor de cada una de las propiedades. Set() sera el encargado de verificar si modificar el objeto en el caso de que se cumpla y 
pasen las validaciones.

const Persona = {nombre: "", age: 0} //Creo un objeto literal
const Handler ={
    set(obj,prop,valor){
        obj[prop] = valor
    }
}
const Pepe = new Proxy(Persona, handler)

1.4) Como dato el objeto sobre el cual se crea el proxy tambien se modifica al modificar su instancia del proxy

                                             38) Propiedades dinamicas de los objetos

1) Basicamente es la creacion de propiedades de forma dinamica. Por Ejemplo si quiero cargar usuarios_ID de forma dinamica en un objeto
lo podre hacer con esto.

const ListaDinamicaUsuarios = {}
const array = ["Pepe", "jose", "Pichi"]
array.forEach((item, index)=> ListaDinamicaUsuarios[`ID_${index+1}`] = item)

2) Otra forma es generarlo dentro del mismo objeto al Encerrarlo entre []. [`id_${numAletorio}`]

                                                        39) THIS

1) THIS: This hace referencia la OBJETO/CLASE sobre la cual estamos trabajando. En el caso de JS cuando hagamos un this hara referencia
al objeto global, es decir a WINDOW.

2) Contexto: El Apuntador obedecera al contexto, es decir que segun el ambito en el que lo use apuntara hacia un u otro lado. Este apuntara
siempre sobre su objeto padre inmediato, si su padre es WINDOW apuntara a el, si esta dentro de otro objeto que esta dentro de WINDOW 
apuntara al objeto y no a window.

2.1) Es decir si THIS: 1) Esta dentro de la funcion de un objeto apuntara al objeto al que le pertenece esa funcion. 2) Si esta dentro
de un constructor de clase apuntara hacia la clase. 3) En una ARROW_FUNCTION apuntara normalmente al ambito global, debido a que no crea
un SCOPE propio como las funciones normales, al no crear un SCOPE su apuntador ira al padre de donde se creo el objeto. 
4) En el Caso de que yo haga un THIS a una propiedad que no existe dentro de mi contexto (SCOPE) saldra a buscarla al contexto global.

3) Si tengo duda de donde apunta lo puedo ver desde el VS CODE y me dice hacia que SCOPE apunta.


                                                      40) Call, Apply y Bind

1) CALL: Me permite definir cual va a ser el contexto que voy a llamar, le tengo que pasar por parametros el contexto (objeto o funcion).
Le puedo pasar parametros secundarios que necesite la funcion a la que estoy llamando o en la construccion de un objeto. En resumen 
CALL define cual va a ser el contexto del apuntador.

function saludar(nombre, saludo){
    console.log(saludo +" "+ nombre+"desde "+ this.lugar)
}
const obj = {lugar: "Local"}
saludar.call(obj, "Pepe", "Hola") //Imprimira "Hola Pepe desde Local"

2) APPLY: Es igual a CALL solo que el pasaje de parametros secundarios es por un array. -- saludar.call(obj,[ "Pepe", "Hola"]) 

3) BIND: Me permite hacer algo similar a CALL al enlazar contextos, me permite decirle al apuntador cual es el contexto al que tiene que 
apuntar. Esto sirve cuando quiero asignar una funcion a otra pero antes definiendole a la funcion a que contexto va a ser asignada.

3.1) La diferencia entre BIND y CALL es que BIND al asignarse no utiliza de inmediato la funcion, sino que deja creado el enlace para 
futuros usos, en cambio CALL se lo utiliza cuando se quiera llamar a la funcion y cambiarle el contexto de inmediato.

                                                            41) JSON
 
1) JSON: Java Script Object Notation. Es un formato ligero de notacion de datos. El Traslado de datos entre Front-End y Back-End se lo 
hace mediante JSONS. Los elementos de un JSON son muy practicamente un calco de como se escriben los objetos de JS. Lo unico que las
KEYS y los values deben estar entre comillas.
{
    "nombre": "Pepe",
    "edad": 35
}
2) Metodos: 1) Parse(): Analiza un valor y la va a convertir a un tipo de dato conocido para JS (excepto undefined).  
            2)stringify(): Convierte un codigo de JS a un formato JSON.

2.1) console.log(JSON.parse('{"name": "Pepe","age": 33,"edad": null,"masculino": true}')) // Devuelve un Objeto en JS

2.2) JSON.stringify(person) //Imprime {"name":"Pepe","age":33,"edad":null,"masculino":true} en formato JSON

                                                         42) WEB API

1) APIS: 1) Eventos. 2) Forms. 3) AJAX - fetch. 4) History. 5) Web Storage. 6) Drag & Drop. 7) Indexed DB. 8) Canvas. 9) DOM.

2) SINTESIS: Las APIS de la web son las formas en las que podemos manipular distintos elementos web mediante JS.

                                                          43) DOM

1) DOM: Document Object Model. Es como los navegadores representan el codigo HTML.

2) El  DOM es lo que nos permite Manipular el HTML con JS atraves de los navegadores.

3) El elemento con el cual accedo a mi HTML mediante JS es document (window.document), es el tendre toda mi estructura HTML.

3.1) 1) GetElementByID(): Me permite capturar un elementos con su ID, al que puedo guardarlo en una variable y manipularlo. 
     2) CreateElement(): Me permite crear un elemento, le tengo que pasar solo el nombre del elemento.
     3) AddEventListener(): 
     4) document.body: devuelve todo el HTML del body, tambien puedo acceder a funciones que me permitan manipular el body dinamicamente 
     5) document.head: devuelve todo el HTML del HEAD. 

4) Las Listas que devuelve HTML no son arrays, sino un nodo los cuales puedo transformar en arrays.

                                             44) Nodos, Elementos y Selectores

1) NODO: Cada elemento del DOM es un nodo, es decir cada etiqueta del documento es un nodo. Pero dentro de JS todas las etiquetas no son
nodos iguales, existen distintos tipos de nodos, los cuales cada uno tendra diferentes metodos.

2) Con los que mas trabajaremos seran los nodos de tipo texto y los nodos de tipo elemento. 1) Nodo-Texto: Es el texto que tiene adentro
una etiqueta. Cada bloque de texto en el documento es un nodo de texto. 2) Nodo-Elemento: Es una Etiqueta HTML como <div>, <body>, <p>

3) Selectores: 1) GetElementByID(): Me permite capturar un elemento por su ID, al que puedo guardarlo en una variable y manipularlo.
               2) querySelector(): Me permite seleccionar elementos con los selectores de HTML (id, clases, elementos), pero es mas 
               lento que GetElementByID(). Solo trae un elemento, si quiero traer una lista lo hago con querySelectorAll() que me 
               devolvera un NodeList.

3.1) document.GetElementByID("MyId"); /// document.querySelector(".MiClase") /// document.querySelectorAll("h1") ///
     document.querySelectorAll("#nav li") -> me traera solo los elementos li que esten dentro de nav.

                                            45) Atributos y Data-Attributes

1) Los atributos son los elementos que tienen las etiquetas HTML.

2) Data-Attribute: Son atributos que yo puedo generar para las etiquetas HTML. <a data-ejemplo=""></a>.

3) GET-VALOR: Para acceder debo colocar document.querySelector("p").getAttribute("NombreAtributo") o 
document.etiquetaAcceder.NombreAtributo (Depende el contexto uso una u otra porque no suele dar los mismos valores)

3.1) Con Document accedo al HTML, con querySelector(o GetElementByID) me poso sobre una etiqueta y con getAttribute()
le indico que atributo

4) SET-VALOR: Para setear el valor de un atributos es: document.etiquetaHtml.atributo = ""; o 
document.querySelector("p").setAttribute("data-peron","Puta peron")

4.1) Con Document accedo al HTML, con querySelector(o GetElementByID) me poso sobre una etiqueta y con setAttribute()
le indico que atributo quiero modificar y luego el valor.

5) Se suele usar const para guardar los elementos del DOM, ya que tienen un funcionamiento similar a los array y
objetos, es decir puede cambiar su contenido pero no lo que son.

5.1) Tambien como convencion se suele llamar las variables que guardan elementos del DOM con el signo $.
     const $miEtiqueta = document.querySelector("img).getAttribute("src");

6) REMOVE-ATRIBUTO: $ElementoDom.removeAttribute("nombre")

7) Data-Attribute: Para acceder a estos lo puedo hacer de la misma forma que un atributo normal o mediante un 
dataset. Esta me devolvera todos los dataAtribute del elemento.
Console.log($element.dataset);

                                                        46) CSS y JS

1) Para agregar estilos de CSS en el DOM mediante JS debo utilizar la propiedad style, el nombre de la propiedad y luego le asigno 
el valor como una variable normal. Tambien para agregar atributos puedo llamar a la funcion setPropierty()

1.1) $element.style.display = "none";
1.1) $element.style.backgroundColor = "#222";
1.2) $element.style.setPropierty("background-color","blue")
1.2) $element.style.removePropierty("background-color")

2) Otra forma para acceder al valor de la propiedad es mediante getComputedStyle y getPropiertyValue, Nos permite leer todos los atributos
CSS de nuestro elemento pero no editarlo, solo leer.

2.1) getComputedStyle($element).getPropiertyValue("color");
2.2) let variable = getComputedStyle($html).getPropiertyValue("--MiColor")

3) ClassList: con esta propiedad podremos llamar a add() y remove(), para agregar o eliminar clases de CSS de nuestra hojas de estilo,
tambien Toggle(), esta si la clase existe la borrara, sino la aÃ±adira. ClassList Emula un arreglo el cual tendra todas las clases del 
elemento HTML.

3.1) $element.ClassList.add("MiClase");
3.1) $element.ClassList.remove("MiClase");
3.1) $element.ClassList.Toggle("MiClase");
3.2) $element.ClassList.contains("MiClase"); //devuelve un true o false.
3.3) $element.className+= ' NuevaClase'
3.4) $element.ClassList.replace("ClaseActual", "ClaseNueva")

4) Para definir variables CSS que esten disponibles en todo el codigo debo declararlas en :root{}. Para acceder a ellas debo acceder 
a la etiqueta HTML (document.documentElement) y el uso de getComputedStyle($Html).getPropiertyValue("--MiVar");

4.1) :root{
    --gris-color: #222;
    --tamanio-fuente: 1.25rem;
}
4.2) $Html.style.setPropierty("--MiColor", "#111")

5) SINTESIS: La diferencia entre el acceso a los estilos mediante el PUNTO o mediante getComputedStyle() (en la lectura) es que con 
el punto solo accedemos a la informacion que este en el atributo STYLE, mientras que con getComputedStyle() tambien accedemos a los 
estilos de la Hoja CSS.
GetComputedStyle() se debe usar al querer leer elementos y la Notacion del PUNTO cuando quiero asignar (usando 
setPropierty/removePropierty o el nombre de la propiedad)

                                            47) Manipulacion de contenido HTML

1) TextContent: Este sirve para agregar contenido textual a un elemento, si quiero agregar texto en estructura HTML no me sirve ya que 
no la reconocera.

$element.TextContent = "Mi texto";

2) innerHTML: Me permite agregar texto utilizando etiquetas HTML, dentro del elemento que estoy referenciando

$element.innerHTML = `<p>mi Texto en Parrafo</p>`;
<div id="element"><p>mi Texto en Parrafo</p></div>

3) outerHTML: Es parecido a innerHTML solo que en vez de agregar el contenido dentro del elemento reemplazara el elemento con lo que 
le pasemos.

4) Sintensis: Depende que necesite insertar dentro de un elemento: 1) Solo texto sin uso de etiquetas HTML usare TextContent. 2) Si 
a ese texto quiero agregarle contenio HTML usare innerHTML. 3) Cuando no quiera colocar HTML dentro de una etiqueta sino reemplazarla
usare outerHTML.


                                                    48) DOM Traversing

1) Me permite capturar las etiquetas HTML (Nodos). Para capturar los Nodos de etiquetas tengo que usar las propiedades que tengan la 
palabra ELEMENT, sino capturare nodos que no son etiquetas.

2) $element.children[]: Me permite acceder a los hijos del elemento segun el numero que le pasemos.

2.1) $element.firstElementChild: El primer elemento HTML hijo
2.2) $element.lastElementChild: El ultimo elemento HTML hijo

3) $element.parentElement: Devuelve la etiqueta padre del elemento HTML.

4) $element.previousElementSibling: Me permite acceder a la etiqueta anterior de igual jerarquia
4.1) $element.nextElementSibling: Me permite acceder a la etiqueta posterior de igual jerarquia

5) closest("etiqueta"): Me devuelve la etiqueta que le pase mas cercana. Si no encuentra devuelve null. 

                                            49) Creando Elementos y Fragmentos

1) Para crear elementos(etiquetas HTML) usaremos el metodo de document CreateElement("etiqueta").

1.1) $element = document.CreateElement("div");

2) Para crear bloques de texto debo generar nodos de texto mediante JS usando document.CreateTextNode("Texto")

2.1) let $text = document.CreateTextNode("Texto Ejemplo)

3) Una vez creado los elementos deberemos agregarlos al arbol HTML del DOM, para ello usaremos la funcion appendChild()

3.1) $elementContainer.appendChild($miDiv); $miDiv.appendChild($text);

const $grid = document.getElementById("grid");
const $div = document.createElement("div"), 
$grid.appendChild($div)

4) El problema de este metodo es que por cada elemento estamos realizando una insercion al DOM lo cual es una accion muy pesada. Para
solucionar esto lo que podemos hacer es crear Fragmentos dinamicos en el DOM (una variable que se crea dinamicamente) y a este 
Fragmento del DOM le podemos estar iterando los elementos, una vez terminado realizamos la insercion de esos elementos mediante el 
fragmento.

const $fragment = document.createDocumentFragment();
array.forEach(item=>{
    const $div = document.createElement("div"); 
    $div.className += "col-12 col-lg-4 col-sm-6 d-flex justify-content-center align-items-center";
    $div.style.flexDirection = "column";
    $fragment.appendChild($div)
    const $img = document.createElement("img");
    $img.className = "imag mb-3";
    $img.style.maxWidth = "250px"
    $img.src = item;
    $div.appendChild($img)
    const ancor = document.createElement("a");
    ancor.style.textDecoration = "none";
    ancor.href = item;
    ancor.textContent = "Ir a Imagen"
    ancor.setAttribute("target", "_blank")
    $div.appendChild(ancor)
})
$grid.appendChild($fragment)

Ahi guardare mis iteraciones, al termino realizare un appendChild($fragmento)

                                                    50) Templates HTML

1) Es una etiqueta HTML que no se renderiza en el DOM, sino que es una especie de plantilla en la que puedo colocar elementos HTML que 
despues puedo utilizar ya construido. <template></template>

2) Para manipularla desde JS accederemos a la etiqueta template con algun metodo pero como template no nos interesa como tal usaremos
   content, que nos traera todo el contenido que tenga la etiqueta template.

2.1) const $template = document.getElementById("templateMyId").content;

3) Cabe destacar que cada vez que queramos iterar los elementos del template deberemos realizar un clon del mismo, ya que por cada 
iteracion utilizaremos el elemento del template string.

      3.1) $temp = document.getElementById("template-card").content;
            array.forEach(el => {
                $temp.querySelector("img").setAttribute("src", el);
                let $clone = document.importNode($temp, true); => ImportNode me permite clonar elementos
                $fragment.appendChild($clone);
            });
            $grid.appendChild($fragment);

3.2) Lo que hacemos aca es que por cada elemento de la template le asignamos valores y creamos una copia de la misma que guardaremos 
en $fragment, ya que en cada vuelta pisaremos los valores de la template HTML.

4) SINTESIS: Template es una plantilla de etiquetas HTML que no se renderiza pero puedo recuperar con JS para modificar y utilizarlas 
para crear mas facilmente elementos HTML(ahorra crear las etiquetas a mano).

                                                51) Modificar Elementos OLD => DEPRECADO

1) $elementContainer.replace($newElement, $oldElement.children[3])
2) $elementContainer.insertBefore($newElement, $cards.firstElementChild)
3) $elementContainer.removeChild(cards.lastElementChild)

                                                 52) Modificar Elementos NEW

1) insertAdjacent: este tiene 3 variantes que me permitira posicionar distintos elementos. 1) insertAdjacentElement(position,element): 
Este me permitira posicionar elementos en una determinada posicion 2) insertAdjacentHTML(position,HTML): Este me permitira posicionar 
Texto con formato de etiquetas HTML. 3) insertAdjacentText(position,text): Este me permitira posicionar etiquetas Texto en una 
determinada posicion

1.1) La posicion de referencia vendra del objeto que estemos utilizando para posicionar. 

1.2) $elementReferencia.insertAdjacentElement("BeforeBegin", $elementNew)
1.2) $elementReferencia.insertAdjacentHTML("BeforeEnd", "<p>Hola</p>")
1.2) $elementReferencia.insertAdjacentText("AfterBegin", "Texto Plano de Ejemplo")

2) Posiciones:  1) BeforeBegin(antes de la etiqueta referencia). 2) AfterBegin(primer hijo de la etiqueta) 3) BeforEnd (ultima etiqueta
de la referencia) 4) AfterEnd (despues de la etiqueta).

                                                53) Manejador de Eventos

1) EVENTOS: Es aquel mecanismo que tenemos en JS para controlar las acciones (del usuario) o responder ante ellas desde JS, definiendo
ciertos comportamientos del documento. Las funciones que se ejecutan/disparan durante un evento se las conoce como EVENT-HANDLER, es 
decir manejadoras de eventos.

2) EVENT-HANDLER: cuando una funcion se convierte en un manejador de eventos puedo acceder a un objeto especial llamado EVENT. Este 
tiene varios atributos con informacion. Los mas destacados son: 1) Type: el tipo de evento que se desencadeno. 2) Target: que etiqueta 
lo ejecuto.
Los manejadores de eventos no pueden obtener parametros como tal, solo a lo sumo el objeto EVENT.

3) Generar-Eventos: 1) La primera forma es generando el evento desde la misma etiqueta HTML: <button onClick="FuncionJs()">
                    2) La segunda es ejecutarlo directamente desde JS, para esto recuperaremos la etiqueta HTML con JS:
                       $elemento.onclick = MiFuncion. No ese deben usar parentesis, tambien puedo usar una funcion anonima o ArrowFunction
                       para declarar. La limitante de esta forma semantica es que solo podre definir un evento del mismo tipo para el 
                       elemento, es decir no puedo definir 2 onClick porque sino se superpondran. 
                       3) En el caso de que necesite colocar mas de un evento usaremos los manejadores multiples. Para hacer uso de 
                       este usaremos AddEventListener(), seria una especie de escuchador de eventos. AddEventListener() recibira 2 
                       parametros: 3.1) El tipo de evento. 3.2) Una funcion ya creada o creamos una ahi mismo

3.2) $but.onclick = MiFuncion;
3.3) $but.addEventListener("click", e => alert("GOLAZO"))

4) Aunque realmente no se puede pasar parametros a un evento mediante un pequeÃ±o truco podemos sortear este problema. Para ello 
usaremos una ARROW_FUNCTION, esta me permitira utilizar una funcion ya definida (o definir una) con parametros. Es decir debemos 
envolver la funcion que necesito parametrizar en una ARROW_FUNCTION, o directamente cargar parametros en la ARROW_FUNCTION y 
definir ahi mismo la funcion.

$element.addEventListener("Click", (e)=> funcionSaludo("Santino"))
$element.addEventListener("click", (e, nombre="Pep")=> {console.log(nombre)})

5) Remover Eventos: Para esto usaremos la funcion removeEventListener(), esta la colocaremos al termino de la ejecucion de mi funcion.
El problema de esto es que si uso una funcion anonima o ARROW_FUNCTION es que a la hora de remover eventos yo debere pasarle el type del
evento y el nombre y al tener una funcion anonima no tendra nombre.

const Funcion = (e, nombre="Pep") => {
    alert(nombre);
    $element.removeEventListener(e.type, Funcion);
}
$element.addEventListener("click", Funcion)

                                                54) Flujo de Eventos y Propagacion => DEPRECADO

1) Cuando Hablamos de flujo de eventos hablamos de como este se propaga a los largo del DOM. Esa propogacion se genera desde el elemento
mas interno hacia los elementos mas externos. Esto se llama fase de burbuja, esto ya viene configurado por defecto en los manejadores 
multiples.
2) Un Ejemplo de propagacion de eventos es que si 2 elementos tienen el mismo tipo de evento (un tipo es click, enter, drag) 
y el elemento hijo dispara el evento tambien se disparara el evento padre y el resto de elementos que esten por encima. Esto es la fase 
de burbuja el Flujo se dispara de arriba hacia abajo.

2.1) Target indica quien disparo el evento, y este no se propaga.

3) Tambien podemos agregar de tercer parametro que es un objeto, ahi podemos llamar a ONCE: al cual le pondremos un T/F si queremos
que nuestro evento se ejecute mas de una vez.

                                                55) stopPropagation & preventDefault

1) Para detener la propagacion lo que debo hacer es en mi Funcion EVENT-HANDLER al final del codigo llamar al metodo del objeto 
event stopPropagation()

$but.addEventListener("click", (e)=>{
  console.log("boton")
  e.stopPropagation()
})

2) Para cambiar el comportamiento por defecto de los elementos en HTML (como por ejemplo button o un ancor) lo unico que debo hacer 
es sobrescribir el evento por default del elemento y usar event.preventDefault(), este cancela el evento por default.

$ancor.addEventListener("click", (e)=>{
    alert("Falso Link");
    e.preventDefault();
});

                                                     56) Delegacion de Eventos => forma mas optima de trabajar con eventos

1) Viene a solucionar el problema de la asignacion de eventos (el tener que usar un ciclo para agregar los eventos, lo cual consume 
mucho rendimiento). En este caso tendre mi evento en un elemento  superior y luego buscando mediante el EVENT.TARGET quien disparo
el evento. Normalmente se asigna estos eventos a la etiquet raiz (HTML).

2) Tambien con esto metodo detenemos la propagacion directamente de raiz. // document.addEventListener("click", (e) => {})

3) Con esta definicion a todo elemento que le hagamos click disparara el evento, para configurar los elementos que queremos que actuen
deberemos validar con condicionales que elemento entro al evento.

3.1) document.addEventListener("click", (e)=> {
    if(e.target.matches(".Clase")){
        e.Alert(Hola)
    }

    if(e.target.matches(".otros div")){
        e.Alert(chau)
    }
})

3.2) Matches() me permite saber si una etiqueta contiene una una clase, id o etiqueta en particular. Devolvera T/F, las formas en las 
que accedera a los elemetos es mediante selectores de CSS. 

4) Eventos JS: 1) Click. 2) dblClick. 3) auxClick. 4) Resize(cuanto se cambia el tamaÃ±o de la pantalla). 5) Scroll. 6) Load(cuando se 
                produce la carga de la pagina) => DOMContentLoaded es mas eficiente.

4.1) En vez de usar el evento LOAD de window es mejor usar DOMContentLoaded de document ya que es mas rapido. Esto debido a que DOMContentLoaded
solo espera que se carguen las etiquetas HTML para ejecutarse, encambio LOAD debe esperar que se carguen los SCRIPTS y las StyleSheets
para ejecutarse, lo cual lo hace mucho mas lento.

document.addEventListener("DOMContentLoaded", (e)=>{})

                                                    57) BOM: Propiedades y Eventos

1) BOM: Son una serie de propiedades y eventos que se encuentran en Window: 1) innerWidth: nos devolvera el ancho de nuestra ventana.
        2) innerHeigth: Devolvera el largo de la ventana. 3) OuterWidth-Heigth: Es el tamaÃ±o de la ventana del navegador.
        4) scrollX-Y: Esto nos devuelve (en px) cuanto se aleja la barra de scroll de su comienzo(left o top)

2) Funciones-Window(BOM): 1) Open("https//youtube.com"): Me permite abrir una ventana emergente. 2) Close(): Igual funcionamiento que 
Open solo que para cerrar, debere guardar la referencia de OPEN. 3) Print(): Me permite que se despligue el menu de impresion del 
navegador. 

3) Objetos-Window(BOM): 1) location: 1.1) location.origin: Me devuelve la ruta HTTP de origen de la pagina, sin enrutamientos. 
                        1.2) location.Protocol: Me devuelve el protocolo que estamos utilizando (si HTTP o HTTPS). 
                        1.3) location.host: devuelve la direccion sin protocolos, el nombre del dominio.  1.4) location.port: devuelve el
                        puerto 1.5) location.hostname: igual que host sin puertos.         
                        1.6) location.href: Me devuelve toda la cadena de la URL, incluyendo los enrutamientos y los parametros URL.
                        1.7) location.hash: devuelve las rutas que utilizan #. 1.8) location.pathname: Me devuelve el enrutamiento    
                        1.9) location.search: me devuelve todos los parametros URL. 1.10) reaload(): me permite recargar la pagina.

                        2) History: 2.1) Length: cuantas paginas visite de ese mismo dominio. 2.2) Back(): esta  funcion me permite 
                        decirle cuantas paginas atras quiero volver. 2.3) Forward(): Lo mismo que back() pero hacia delante.
                        2.4) Go(): Es una combinacion de los metodos anteriores, numeros positivos son hacia delante y negativos 
                        hacia atras.

                        3) Navigator: es un objeto complejo que cuenta con varias APIS (bluetooht, clipboard, geolocalizacion, user agent).
                        3.1) geolocalizacion: Api de geolocalizacion. 3.2) media-devices: detectar dispositivos conectados. 
                        3.3) onLine: devuelve un T/F si el pierde o recupera la conexion. 3.4) ServiceWorker: Es un API que permite
                        convertir un sitio web en una app instalable. 3.5) user.agent: Me informacion del navegador y el dispositivo en 
                        el cual se esta ejecutando mi app web.

DATO: la aclaracion de (BOM) es porque son elementos Window pero que pertenecen a la Api Web de BOM y no de DOM. El BOM


                                                        58) DATOS PRACTICOS

1) Acceder a Teclas mediante su evento: e.key.toLowerCase()==='u' && e.altKey

2) Los eventos de presion de teclas deben estar en el script principal y no ser importadas.

3) Deteccion de coliciones: utilizaremos el metodo getBoundingClientRect(), Ver constantemente la posicion y tamaÃ±o del objeto. 
Basicamente con esta funcion puedo tomar los valores de los bordes de los elementos y utilizarlos para saber si van a colisionar o 
en que posicion se encuentran.

let limitBall = $pelota.getBoundingClientRect();
let limitContainer = document.querySelector(claseContainer).getBoundingClientRect();

if(e.key === "ArrowRight" && limitBall.right+15<limitContainer.right)move(e.key)

4) Sacar tiempos de Cuenta atras
h = Math.floor((date.getTime()/cantidadMSxhora)%24),
m = Math.floor((date.getTime()/cantidadMSxMinuto)%60),
s = Math.floor((date.getTime()/1000)%60)

5) Con slice() si le pasamos numeros negativos empezara a agarrar numeros desde los ultimos caracteres
("0"+Math.floor((tiempo.getTime()/1000)%60)).slice(-2)

6) scrollTop: Representa la distancia del scroll con respecto al Top, puedo setearle valores.

6.1) Como Scrollear con click de Button: document.documentElement.scrollTop = 0;

6.2) variante: w.scrollTo({behavior: "smooth",top: 0})

7) Seleccionar elementos que tengan ambas 2 clases: .pelota-container.dark-mode{background-color: #222;}

7.1) Seleccionar elementos que tengan ambas 1 clase: h1.dark-mode{background-color: #222;}

8) Seleccionar por Data-Atribute con querySelector(): document.querySelector(`[${variable}]`)

9) Los Data-Atribute Suelen ser utiles para desencadenar eventos de los componentes.

                                                         59) API LOCAL STORAGE

1) Local Storage: Es una forma de almacenamiento web que permite a las aplicaciones web almacenar datos de forma persistente en los 
navegadores del usuario. Es una mejora a las COOKIES.