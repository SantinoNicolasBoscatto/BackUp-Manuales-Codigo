                                                        1) Api REST

API REST: Es una aplicacion Web desde el lado del Back-End ( un servicio web), en el cual tenemos una serie de Metodos 
configurados que realizan ciertas funcionalidades como la interaccion con la base de datos, Logica, etc, que puede ser
consumida (utilizada) mediante el protocolo HTTPS por cualquier tipo de cliente que entienda el protocolo HTTPS.
En esta API vamos a crear distintos metodos que necesitemos utilizar, para cada uno de estos metodos definiremos una ruta
y cada una de esas rutas tendra un Metodo HTTPS diferente (Get, Head, Post, Put, Delete, Connect, Options, Path).
Normalmente el ApiRest devuelve los datos en un JSON (Es mas organizada y liviana que un XML).

Un API es como una página web, pero no para ser leída por personas sino para ser leídas por programas.

Un API no lo consume/Utiliza una persona, la consume/Utiliza un programa. Al consumirla no lo hace a través de un navegador
de internet, sino que envía un pedido a una dirección http también, pero en lugar de recibir un HTML, una API va a regresar
un contenido JSON para ser consumido por el programa que envió el pedido.

                                                    2) string vs StringBuilder

1) string: string es inmutable, es decir que cada vez que se crea un objeto string este ya no puedo cambiar, su contenido no puede ser 
modificado. Cada vez que se quiere modificar un string no se modifica sino que crea una instancia nueva.

2) StringBuilder: Es Mutable, basicamente lo opuesto a string, este se puede  modificar despues de su creacion sin tener un instanciar 
un nuevo StringBuilder.

3) Cuando Usar uno u Otro: La ventaja de StringBuilder es que da mucha mas eficacia en rendimiento cuando estoy constantemente modificando
una cadena, pero si mi cadena va a permanecer igual durante toda mi aplicacion es mejor usar solo string.

                                                        3) TypeOff

1) typeoff: Devuelve un objeto Type que representa un tipo de dato. Basicamente devuelve un Tipo de Dato.

2) nameoff: Devuelve el nombre de una variable.

                                                        4) Compilador

1) Procesos de Compilacion de C#: 1) Compilador, esto convierte nuestro codigo en Intermediate Language (IL) 2) Entramos en la fase de 
CLR donde con JIT (Just In Time) compilamos el IL en Lenguaje Binario.

                                                       5) Tipos de Dato

1) Build In Type: Tipos de datos ya definidos por el framework que solo debo llamar para utilizarlos (int, string, char, bool, object, 
dynamic).

2) User defined Type: Poder extender los tipos de datos existentes y crear mis propios tipos de datos (struct, enum, class, interface, 
array, delegate).

                                                        6) Parametros y Tuplas

1) En el caso de que tenga un metodo con varios parametros para pasarle una forma facil de colocar los valores sin equivocarse en el 
orden del paso de parametros es colocar el nombre del parametro original y ":" y luego el valor que ese parametro va a tomar.

EJ: void MiFuncion(mensajeParametro: "Hola", numeroEJ: 33);

2) Definir Parametro de Salida: void CalcularCosto(int costoUno, int Impuesto, out int total);
                                     int saldo = 0;
                                     CalcularCosto(100, 21, out saldo);


3) Tuplas: Son estructuras de datos ligeras, me permiten almacenar conjunto de datos de formas sencillas y se las suele usar para que 
las funciones puedan devolver mas de un tipo de dato.

EJ: (int saldo, string cargo) informe = (0, "");

EJ2: var miTupla = (20,"Tupla",false)

3.1) Uso:   void CalcularCosto(int costoUno, int Impuesto, out (int,string) total)
            {
                total.Item1 = costoUno+Impuesto;
                total.Item2 = "Gastos";
            }
            (int saldo, string cargo) informe;
            informe.saldo = 0;
            CalcularCosto(100, 21, out informe);
            Console.WriteLine(informe);

3.2) Segunda Forma de Retornar Tupla: (int, string) Costo(int saldo, int impuesto,string causa)
                                      {
                                        saldo += impuesto;
                                        return (saldo, causa);
                                      }
                                      var Tupla = Costo(100, 21, "FURRY ZONE 4");
.

                                                            7) Colecciones

1) List: RemoveAt(4) => Elimina por indice // Remove("Value") => Elimina por valor. // Contains("Value") => Devuelve T/F segun el valor 
que le pase. // Exists(x=>x.length > 10) => Esta funcion me permite filtrar por distintos atributos, devuelve un true si encuentra.
 Find(x=>x.StartWith("A")) => Find basicamente busca y devuelve el elemento, FindAll() devolvera un Enum

2) LinkedList: A diferencia de las listas estas no cuentan con un indice. Para Acceder a los elementos se los hace mediante un acceso
secuencial. Es decir para acceder a un elemento nos debemos basar en el elemento anterior y/o posterior. 
Metodos: AddFirst()/AddLast() // AddAfter(referencia, "Agregado")/AddBefore() // ElementAtOrDefault(0) Selecciona por indice // 
RemoveFirst()/RemoveLast() // Remove() Elimina pasandole el valor del elemento

Cada Elemento de Estas listas los podemos Conocer como un LinkedListNode, estos tendran los atributos de Next, Previous y Value con los 
cuales podremos usar para acceder a otros elementos o mostrar su valor.

3) Stack: Es una coleccion que tiene la peculiaridad de que el ultimo elemento que agregue siempre se posicionara arriba del resto.
Metodo: Push() => Me permite insertar elementos // Peek() => Me trae el Primer Elemento // Pop() Me devolvera un elemento y lo eliminara
de la coleccion // Contains("") => devuelve T/F // ElementAt(0)

4) Queue: Es Opuesto al funcionamiento del Stack. Metodos: Enqueue() => Agrega un elemento //  Peek() // Dequeue() Me devolvera un 
elemento y lo eliminara de la coleccion  // Contains("") // ElementAt(0)

5) Dictionary: Es una coleccion similar al List, Pero en vez de funcionar con indices funciona con una especie de llave/valor. El Primer
generic definira el tipo de mi KEY y el segundo el tipo de mi VALUE. No puede haber 2 elementos en el Dictionary con el mismo KEY.
Para acceder a algun elemento lo debo hacer mediante su KEY: "miDiccionario["miKey"]"
Metodos: Add("Key", "Value") // TryAdd("Key", "Value") => devuelve un bool de si es valido ingresar esa Key-Value al diccionario. //
         ElementAt(0) // ContainsKey("Key") => esta funcion buscara el elemento con la Key que le pasamos y devuelve un T/F 
         // ContainsValue("Value") // Remove("Key")

Dictionary<string, string> miDiccionario = new Dictionary<string, string>();

                                                                8) Delegados

1) Delegados: Basicamente un delegate es una variable en la cual podemos guardar una funcion (no su retorno, sino su logica) y luego
llamarla y ejecutarla. Los argumentos y tipo de dato que devuelva la funcion debe coincidir con la firma del delegate.

MyDelegate delegado = func1;                           //Asignacion de una funcion a un delegado.
delegado(33,77);                                       //Ejecucion
delegado = func2;                                      //Sobrescribo la funcion del delegado.
public delegate string MyDelegate(int arg1, int arg2); //Declaracion de un delegado. => SIEMPRE VA AL ULTIMO

2) Delegates Anonimos: Es basicamente un delegate al cual le asigno una logica de funcion en el momento de su iniciacion 
mediante un delegate sin nombre.

MiDelegado delegado = delegate(int arg){
    return arg *= 1,21;
}
delegado(100);
public delegate int MiDelegado(int arg);

3) Delegates Compuestos: Basicamente seria un delegate que concatene otros Delegates. Para poder concatenar 2 delegates estos deben 
si o si tener la misma firma/cabecera.

public delegate void MyDelegate(string msg);
MyDelegate delegate1 = (msg) => Console.WriteLine("Delegado 1 dice: " + msg);
MyDelegate delegate2 = (msg) => Console.WriteLine("Delegado 2 dice: " + msg);

// Concatenación de los delegados
MyDelegate delegate3 = delegate1 + delegate2;

// Invocación del delegado concatenado
delegate3("Hola, mundo!");

3.1) Remover una Funcion del Delegate Compuesto: delegate3 -= delegate2; (queda solo la funcion del delegate1)


                                                      9) Creacion de Eventos   

1) Events: Son funciones "Asincronas", las cuales se pueden ejecutar sin la necesidad de que otra accion haya terminado. Estan basadas
en delegates. Para poder crear un evento debo usar la palabra reservada event.

2) Crear Evento: Primero debo definir un delegate, luego para crear el evento debo usar la palabra reservada event y asignarle el
delegate que cree anteriormente y colocarle un nombre. Con esto tengo creado el evento y puedo llamarlo como si fuera una 
funcion. Los parametros y returns que haga dependeran de como este definido el delegado en el que se base. Tengo la opcion de en vez 
de suscribir el evento a una funcion y definirla lo puedo hacer creando un delegate Anonimo.
Tambien puedo utilizar otra clase que me ofrece C# para crear eventos, que es la plantilla base: EventHandler.
    
    private string? TheValue;                           //Class EventCreate
    public string Value                                 //Class EventCreate
    {
        get { return TheValue!; }
        set
        {
            this.TheValue = value;
            this.valueChanged(TheValue);
        }
    }
    public event MiEventoHandler valueChanged;          //Class EventCreate

    public delegate void MiEventoHandler(string value); //Class Program
    var obj = new EventCreate();                        //Class Program
    obj.valueChanged += valueChanged;                   //Class Program
    void valueChanged(string value){Action();}          //Class Program
    obj.Value = "Changed";                              //Class Program

3) Eventos Encadenados: Al igual que los delegates puedo acumular/concatenar funciones dentro de un evento.

    obj.valueChanged += valueChanged;                   
    void valueChanged(string value){Action(value);}
    obj.valueChanged += delegate(string value){ActionSecundaria(value);}          

4) Eventos Por Defecto: Este es la plantilla por defecto que nos ofrece .NET para crear eventos. En ella encontraremos 2 parametros:
    1) object sender: este es la entidad que disparo el evento. 2) EventArgs e: Me proporciona data del evento. Para poder utilizar 
Esta plantilla en mis clases debere heredar de la clase EventArgs.
Pasos Para Crear Eventos en C#: 1) Creo una clase DTO que heredara de EventArgs, dentro de estas solo crearemos las propiedades que 
queremos nuestro evento. 2) En la clase donde se realiza el disparo del evento debo crear el evento, utilizaremos EventHandler<> y dentro
del generic colocaremos nuestra clase DTO. 3) En la llamada al Evento le pasaremos 2 parametro, estos son sender y e. 4) Al final 
cuando llame a mi Evento le definire la logica para que actue, toda esto es similar a como funciona un delegado.

La diferencia con la forma de crear eventos anterior es que La firma del evento en este caso la define EventHandler(que tiene 2 parametros
sender y e) en cambio en la otra nosotros definimos un delegado manualmente sobre el cual se basara la firma. Esto debido a que 
EventHandler Es en si un Delegado.

1) public EventDTO : EventArgs {public string data;}
2) public event EventHandler<EventDTO> MyEvent;
3) MyEvent(this, new EventDTO{data = value});
4) obj.MyEvent += MyEvent;
   void MyEvent(object? sender, EventDTO e)
   {
      Console.WriteLine("Prueba"+e.data);
}


                                                        10) Lambda Functions

1) Lambda: Es una forma de escribir funciones anonimas y delegates anonimos. Se los utiliza cuando la logica a implementar es 
pequeña y compacta. Se escribe similar a JS, si necesito mas de una linea de codigo en la logica abro llaves. En sintesis las 
arrow-functions son funciones anonimas que me permiten simplificar la escritura de codigo.

Multiplicacion f = (x,y) =>  x * y;
Console.WriteLine(f(5,3)); // Devuelve 15
public delegate int Multiplicacion(int x, int y);

Calculo f = (x,y) => {
     int r = x * y;
     r = r/3+33;
     return r;
};

Console.WriteLine(f(5,3)); // Devuelve 15
public delegate int Calculo(int x, int y);

                                                            11) Interface  
                                                        
1) Por temas de escalabilidad en el desarrollo de software implementamos relaciones blandas/flexibles entre los componentes de una app.
Por eso es que no basamos nuestra logica y comunicacion en instancias de clases, sino que por ese mismo motivo utilizamos las interfaces
o las clases abastractas.

2) Interfaz Vs Clase Abstracta: 1) La Interfaz permite una multiple implmentacion (herencia) sobre una clase, en cambio una clase hija 
solo puede heredar de una clase padre. 2) La CA permite implementar tanto metodos abstractos (metodos sin logica solo con la firma 
definida) como metodos concretos (con firma y logica). En Cambio en la interfaz solo puedo definir metodos abstractos. 3) La CA 
me permite manipular modificadores de visibilidad de sus elementos (public, private, protected), la interfaz hara todo sus 
elemento publicos. 4) La Interfaz es mas rapida que la implementacion de una clase abstracta.

3) Interfaz: Una interfaz es donde voy a declarar las firmas de las funciones, mas no su logica. La clase que implemente las interfaces
debera si o si implementar todas las funciones que se declaren en la interfaz.


                                                            12) Generics

1) Generics: Estos introducen el concepto de tipos de parametros para .NET, esto permite diseñar libremente clases y metodos. Es decir 
que los generic son tipos de datos no definidos en las clases, son datos a definir por el usuario. Esto sirve por ejemplo para las listas,
estas implementan un Generic para definir el tipo de la lista, no se encierran en que la lista debe de ser de un tipo de dato, sino crean
la lista con un generic y basan la logica trabajando sobre ese Generic, luego el usuario definira que tipo de dato usara.

public class Stack<T>
{
    public void Agregar(T objeto){}
    public T Devolver() {}
}

2) Beneficios: 1) Reuso de Codigo, desarrollo una vez la logica y lo puedo utilizar con cualquier tipo de dato. 2) Evito usar object y 
realizar los pesados casteos. 3) Performance al no realizar unboxing y Boxing.


3) Boxing: Guardar una varible (un int por EJ) en una varible padre superior (object por ejemplo)
3.1) Un-Boxing: Basicamente es Castear ese tipo de Dato. 
3.2) El problema de estas tecnicas es que si abusamos de ellas el programa se hara lento, debido a que son tecnicas pesadas. Por esto 
es que se recurre a los generics en la creacion de funciones antes de querer meter elementos objects y castearlos.

4) En el momento de que un constructor me pida una Interfaz para su construccion lo que puedo hacer es pasarle  un objeto que implemente
esa interfaz.

5) Constraints Generics: Al definir una clase generica esto deriva en que cualquiera pueda implementar esta clase generica. En el caso 
de que yo quiera restringir el acceso a mi clase generica puedo definirle Constraints Genericos. Esto me permitira evitar errores en las 
implementaciones de Generics. Para aplicar una constraint a un generic lo aplico con la palabra Where y una condicion del Generic. En 
el ejemplo defino que para poder usar esta interfaz generic el objeto generico debe implementar la interfaz IComparable

EJ: public interface IEstudianteRepository<T> where T : IComparable<T>
EJ: public class generic<T> where T : ClaseEJ, ISoyInterfaz // En este ejemplo estoy diciendo que el dato generico debe implentar una 
interfaz y heredar o ser ClaseEJ.
EJ: public interface IEstudianteRepository<T> where T : IComparable<T>, new()   //El new() obliga a la clase a tener un constructor sin 
parametros

6) En el Caso de tener un constructor vacio el cual queremos que cargue valores por defecto en base a otro constructor con parametros 
lo haremos de la siguiente forma: 

public MiClase () : this(arg1,arg2)
{}

                                                          13) Reflection

1) Reflection: Esta herramienta me permite obtener/acceder la informacion de un tipo, sus campos, metodos, propiedades e Interfaces 
que aplica. Basicamente permite analizar el contenido de un ensamblado durante la ejecucion.
La reflexión en .NET te permite acceder y manipular elementos que ya han pasado la primera fase de compilación (donde se genera el 
código IL) y se encuentran en ese formato intermedio. 

2) Usos: 1) Obtener Informacion: Puedes explorar los tipos, sus miembros y atributos en tiempo de ejecución. 2) Crear instancias 
dinámicas: Puedes crear objetos de tipos desconocidos previamente. 3) Obtener e Invocar métodos: Puedes llamar métodos en tiempo de 
ejecución. 4) Acceder a campos y propiedades: Puedes leer o modificar valores de campos y propiedades.

2.1) Para extraer el tipo de un generic en tiempo de ejecucion lo hago con typeof(), esto me devolvera toda la informacion sobre 
el tipo de dato y acceso a propiedades y metodos utiles.

var openInterface = typeof(IProcessor<>);
Console.WriteLine($"Es Generic? {openInterface.IsGenericType}");
Console.WriteLine($"Es Definicion Generic? {openInterface.IsGenericTypeDefinition}");

La diferencuia entre IsGenericType y IsGenericTypeDefinition es que en la primera pregunto si es generica en su declaracion y la 
otra si es generica en su implementacion (si en este caso al no pasarle ningun otro tipo de dato al IProcessor).

2.2)

2.3) Obtener metodos: var metodos = type.GetMethods(BindingFlags.Public);










X) Array.Sort(): Es un metodo que me permite ordenar un array, pero antes debo utilizar la interfaz IComparable(), y desarrollar una 
logica en esta para setear la comparacion.
X) Operador IS: Me permite saber si un elemento ES un objecto determinado o una interface.
X) Operador AS: Si quiero castear ciertos parametros un objeto (por ejemplo B hereda de A, y quiero que un Objeto A tome
los valores de las propiedades de un objeto B, pero solo de las propiedades que existen en A) lo puedo hacer con el operador AS.
B obj = new B();
A obj2 = obj as A; // obj2 quedara cargado en sus propiedades con los valores del obj B.

Dato: Una funcion, delegado u objeto Anonimo se refiere a un elemento que funciona como tal pero que no tiene nombre (no esta definido).