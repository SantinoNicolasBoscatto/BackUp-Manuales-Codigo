5Para instalar SQL son 2 etapas. 1) instalar el motor de SQL SERVER que sera el "servidor" como tal, para esto descargamos el SETUP de 
la version mas actual, vamos a instalation y configuramos lo que queramos. 2) Luego toca instalar el acceso visual al SQL SERVER que seria
SQL MANAGEMENT STUDIO.

SQL MANAGEMENT: Desde Este podemos acceder a diferentes bases de datos, en ellas podemos crear tablas, STORE-PROCEDURES, Diagramas de 
Base de Datos, ETC. Entonces este programa nos permitira gestionar el motor SQL y configurar todo lo referido a nuestras Bases de 
Datos. Cada Base de Datos que tengamos por motor SQL se llamaran Instancias (Similar a cada objeto creado, que es una instancia de una clase).

En este motor tenemos 2 Paneles: 1) El Object Explorer, ahi encontraremos las instancias de nuestro Motor SQL y las configuraciones de 
esa Base de Datos (Sus Tablas, Columnas, Triggers, Store-Procedures, Seguridad, Etc). 2) Y el otro se llama Solution Explorer. Si yo tengo un 
Query Abierto, y le doy click a FILE me permitira guardar la solucion.
A esta Solucion le Podremos agregar Proyectos y dentro de esos proyectos las Querys. Esto Es Util para poder organizar bien los Script 
y Querys que voy a utilizar y no tenerlo todo en un archivo o varios archivos desparramados. Estos Querys Debo crearlos En la Carpeta 
Llamada Queries.

En los Menus Superiores podemos encontrar FILE(Podemos Abrir o Cerrar la conexion, guardar o Cargar Querys/Soluciones), View (Nos permite 
el acceso a todas las ventanas de SQL MANAGEMENT), El Menu QUERY, Project (Crear un nuevo Projecto, Item, Query o Conexion),Tools.
Dentro de SQL MANAGEMENT hay una Herramiente muy interesante que es Parse, esta permite verificar Consulta esta bien o mal escrita, pero
a diferencia de EXECUTE esta no manda una Consulta a la Base, solo se encarga de que la consulta este correctamente escrita. Tambien 
tenemos una Herramienta para comentar codigo  y descomentarlo. Tambien hay otro funcion de identado.

Una Solucion, Al igual que en .NET, Puede tener varios Proyectos. En Sintesis Esta solucion me servira para poder organizar mis 
Scripts de forma eficiente y de forma modular.

Base De Datos: Las Base de Datos van a contar con Tablas(El cual esta Conformadas por los Campos), Campos(los campos son propiedades 
de las tablas, estas tienen una Tipo de Dato) y Registros.

Campos: Las Propiedades que componen a la tabla.

Registro: El Registro son los datos cargados de la tabla, se los ve en ya que estan en las filas

Valor Null: Un Valor Null Representa la Ausencia de Valor de una columna en una Tabla, es distinto a "" o 0 debido a que estos sin son
valores que ocupan espacio en memoria, encambio Null representa la ausencia de Valor.

PRIMARY KEY: Para Definir una PRIMARY KEY lo hacemos sobre algun campo de nuestra Tabla. La PRIMARY KEY se utiliza para aquellos registros
que queremos que sean unicos en nuestras bases de datos, como lo pueden ser los ID. 

1) La PRIMARY KEY me permite reprensentar de forma Unica a Cada registro de la tabla. 2) Esta PRIMARY KEY sera NOT NULL, es decir no 
aceptara Null como valor. 3) Una Tabla puede tener mas de un campo con PK, a eso lo llamaremos clave compuesta. 4) Pero cada tabla 
solo tendra una PK.

FOREIGN KEY: 1) Una FK es una relacion entre 2 tablas, en donde En la Tabla A pongo un valor que lo reutilizare en la Tabla B. El valor 
del campo de las FK (Su tipo de dato) debe ser igual en ambos llaves. La FK se declara en la tabla A. 2) Acepta NULL. 
3) Una Tabla puede tener mas de una FK. 4) Estas FK se suelen configurar para implementar las reglas de integridad referencial.
5) Esto tambien me permite una Consistencia de Datos, es decir que en la tabla B yo no voy a poder cargar Registros de Datos que no
existan en la tabla A. 6) Los registros de la FK tabla A Determinara la Serie de valores que puede tener la FK de la tabla B.

Regla de Integridad Referencial: Si se configuro una FK Esto permite que no se puedan borrar registros de la Tabla A (Elementos) si 
existen registros de estos en una Tabla B. 
EJ: Si tengo la tabla A Elementos y ahi un campo con Clave foranea 'Agua', si la tabla B que esta relacionada con la FK tiene el valor 
'Agua' no podre  borrar el Registro 'Agua' de la tabla A.
 
Normalizacion De Base de Datos: Una de las ventajas de la Normalizacion es que se evitan problemas de borrado, insercion y Modificacion
de Datos y poder realizar menos trabajo al necesitar hacer una ampliacion de la base. Tenemos 3 Formas de Normalizacion de Tablas:

1) Una Tabla estara en Primera Forma Normal Existe una Clave principal, Todos los atributos son atomicos (que no se trate de guardar mas 
de un valor en un campo) y no debe haber valores nulos.

2) Para que una Tabla este en Segunda Forma Normal Todos los Atributos deben estar relacionados directamente a la PK. Es decir mis 
Atributos no claves deben depender funcionalmente exclusivamente de mi PK, si esto no se cumple no llega a la segunda Normalizacion.

3) Una Tabla esta en Tercera Forma Normal solo si los campo/Atributos solo dependen de la Clave PRIMARY y no de otro atributo no clave.
Es decir que los atributos no clave dependan de otro no clave, sino que todos los atributos no claves dependan de atributos claves para
que no se puedan a llegar a mezclar datos.

En Sintesis la 1-FN Es que cada registro sea unico, que no exista un mismo registro repetido y que se utilice una PK. 2-FN es que los
Atributos no claves de la tabla dependan todos de la PK. 3-FN es que ningun atributo no Clave depende de otro no clave, sino que todo 
atributo no clave dependa de una PK.

Tipo De Dato: al igual que en programacion el tipo de dato se refiere al formato del valor que se almacena en un campo. Dentro de estos 
estas los Numericos: 1) INT (Ocupa 4 Bytes) 2) TINYINT (0 a 255, ocupa 1 byte) 3) BIT (0 o 1) 4) Money (Ocupa 8 bytes, admite solo 4 decimales) 
5) Decimal (el mas preciso a nivel decimal)  

Los de Texto: 6) Char (1 byte por cada caracter, de 1 a 8000 Caracteres, se lo tiene que usar cuando sabemos la cantidad exacta de 
Caracteres que va a usar cada registro para ese campo, como las siglas de los paises)  7) VarChar (1 byte por caracter variable, de 1 a 
8000 Caracteres, es decir segun la cantidad de caracteres que le carguemos a ese campo ese va a ser el espacio que ocupara)

Los de Tiempo: 8) DateTime

Para Crear nuestra base es tan sencillo como abrir en Object Explorer Database, new Database y configurar el nombre y la ruta. Esto
nos generara 2 Archivos: 1) uno de Extension MDF (Master Data File) Este es el principal archivo de la Base de datos, este contiene 
las tablas, indices, Procesos Almacenados y otros objetos. 2) El Archivo LDF, es un archivo de registro de Consultas / Transacciones 
de una Base SQL, Registra toda Transaccion y cambio en la base y permite la recuperacion y restauracion de la misma.

Para elegir la base por defecto en la que vamos a trabajar tengo que entrar a Security, a mi usuario y ahi selecciono la Default DB.


                                             1.0) Crear Tabla Por Object Explorer

Para Crear una Tabla por el explorador es tan sencillo como abrir la base, la carpeta de tablas y en New encontraremos la opcion de Table.
Para configurar la tabla tendremos que configurar sus columnas, en este caso tendremos 3 Atributos para colocarles a los campos de la 
Base de Datos: 1) Column Name. 2) Data Type. 3) Allow Nulls. Para guardar le damos Ctrl-S

                                         2.0) Modificar Tabla existente Por Object Explorer

Para Modificar una Tabla ya existente deberemos darle click derecho a la tabla y acceder a Desing. Ahi haremos las modificaciones pero
la primera vez que queramos guardar los cambios no nos dejara por tema de configuracion. Para ello iremos a Options en la caja Tools,
Designers y Desmarcamos la Opcion de Prevent Saving.

                                                3.0) Definir PK Mediante Desing

Es tan simple como ir a Desing, seleccionar el campo y arriba a la derecha veremos un Logo de KEY, lo pulsamos y nuestro campo se volvera
una PK.

                                                4.0) Activar Propiedad Identity

Para configurar Identity en el Desing deberemos seleccionar el campo e ir a column propierties y ahi ir a la propiedad Is Identity y 
poner que si. Esta Propiedad se le suele colocar a la PK de tipo int, debido a que este al insertarse un registro  se crea 
automaticamente incrementando en uno su valor del registro anterior. 
Podemos Tener mas de un campo con Is Identity. Este campo no puede ser borrado.



                                             0.1) Crear Base de Datos Por T-SQL
                                                                                 
                                              CREATE DATABASE *Nombre de Base*

                                             1.1) Crear Tabla en T-SQL 
 
                                            CREATE TABLE *Nombre Tabla*(
                                                *Nombre Campo* *Tipo* Identity (1,1) ,
                                                Nombre Varchar(50) Not Null,
                                                Apellido Varchar(50) Null
                                                Fecha Date null,
                                                IdPais Char(3) not null
                                                CONSTRAINT *PK_NombreLlave* PRIMARY KEY (*Nombre del Campo*)
                                            )

Definir PRIMARY KEY Compuesta:  En el caso que yo necesite repetir una clave primaria para relacionar datos lo que se suele hacer es 
Crear PK compuestas asi podemos evitar la repeticion. Esto Permite una Mayor Flexibilidad a la hora de definir las PK.


Crear Un Tipo De Dato: EN SQL puedo crear tipos de datos con nombres personalizados, estos tipos de datos se basan en una ya 
existente pero cambia su nombre. Esto me evita que otro usuario que pueda modificar la BD no pueda utilizar otro tipo de datos 
para una tabla. Para hacer esto lo podemos hacer desde la BD, en Programability/Types/User-Defined-Data-Types.
Tambien en T-SQL lo puede hacer poniendo: 

                                        CREATE TYPE *Nombre*  from *tipo de dato* null/not null

                                                        X) CONSTRAINTS

Conceptos de Relaciones entre Tablas: 
Primero que nada las relaciones entre tablas no son obligatorias, una base puede funcionar sin tablas relacionadas. Sin embargo una 
tabla sin relaciones puede correr el riesgo de perder la integridad de los datos en las tablas, ya que no tiene definidas las reglas 
de integridad referencial RIR.
Estas Reglas (CONSTRAINTS) son relaciones entre tablas, en donde un Campo PK se relaciona con un campo de otra tabla al cual llamamos FK.
Esto  me sirve para que yo no pueda colocar un valor en la FK que no este en mi PK, permitiendo manejar mejor lo Consistencia de datos.
Otra Caracteristica es que no podremos borrar los registros PK de una tabla si estas se encuntran en una FK de otra tabla.
Esto mismo me evita los errores en el manejo de datos al evitar que Inserte o Actualice Datos inexistentes o que borre datos.

Crear desde el Explorer: Vamos a la tabla a la cual queremos crearle una relacion y vamos a su Keys y seleccionamos crear new FK. Ahi
Pondremos Tables and Columns Spec y ahi nos dejara configurar a que tabla le queremos colocar esta clave foranea. Estas claves foraneas
son claves primarias de una tabla A que son reutilizadas en una tabla B, los registros que tenga en la tabla A limitaran que registros 
puedo poner en la tabla B. Como dato la FOREIGN KEY que vamos a Crear (Especificar) ya debe tener el campo creado en la tabla B, es decir
si a la tabla B le quiero hacer una FK de IdPais, en la tabla B debe existir un Idpais.

La tabla A sera la tabla principal que manejara los registros de los datos, la tabla B sera a la cual se le restringira el inserte de 
registros segun los valores que dicte A.
     

Relacion Uno a Muchos: Es una relacion en la que tenemos una PK que va a tener registros unicos que van a estar representados en la 
tabla B. Es decir Se conecta un Registro de un campo a muchos registros de ese campo, es decir un Registro de una tabla para muchos
registros de otra tabla.

Relacion Muchos a Muchos: Es cuando Una tabla puede estar relacionada con muchos registros de otra tabla.Es ahi en que un registro puede
tener muchos otros registros, es decir un mismo medico puede tener muchas especialidades. O una especilidad con muchos medicos. 
Es decir un medico Puede tener Varios Id de Espacializaciones y las especializaciones varios IdMedico, en cambio el pais tiene varios 
pacientes, pero el paciente un solo pais.
Estas Relaciones de muchos a muchos si o si necesitan tener una Tabla Intermediaria, sino estas no se pueden relacionar entre si, ya que
sino no podriamos configurar las PK.

Relacion Uno a Uno: Para cada Registro solo voy a tener un registro. Es decir que cada InfoPaciente va a tener un IdPaciente, y cada 
paciente va a tener un registro. En esta Relacion Uno a Uno es indiferente donde definir la FK.

En Sintesis 1) Una Relacion de uno a Muchos Se da cuando se conecta una PK con un campo de una Tabla que no es clave. 2) Una Relacion 
Muchos a Muchos se da cuando una tabla Intermediaria tiene 2 PK que vienen de otras 2 tablas y por ende por cada registro de una puede 
haber muchos registros de la otra. 3) La relacion Uno a Uno se da cuando se conectan 2 PK, esto significa que por cada registro solo 
puede haber otro registro.

Tablas de Relacion: Son tablas en las que traeremos los ID de otras tablas para generar relaciones. En estas tablas no colocamos Identity 
debido a que estas tablas van a tomar directamente valores de otras tablas, no son registros nuevos que se generan, estamos tomando 
registros ya existentes.

Las Reglas de Integridad relacional son basicamente las relaciones entre las tablas donde la tabla A le pasa el Campo PK a 
una tabla B que la toma en un campo FK.


                                                         1) CLAUSULAS

CLAUSULAS SQL: Las CLAUSULAS basicamente son condiciones que se le hacen a las tablas para que estas devuelvan un valor.
 
 1) TOP => Con esta CLAUSULAS podemos indicar que  Numero de Filas queremos seleccionar. EJ: Select Top 5 * Pacientes 

2) Order BY => Con esta Clausula traere los registro de forma ordenada, si quiero que sea ascendente o descendente es tan facil con 
poenr ASC o DESC. EJ: Select Nombre, Precio from Auto Order By Precio DESC.

3) DISTINCT => Me Permite Traer los Valores De forma agrupada (sin repeticiones) de una Columna/Campo
   EJ: Select DISTINCT Tanque from Autos.

4) Group By => Hace algo similar a DISTINCT, Permite Traer los Valores De forma agrupada (sin repeticiones) de una Columna/Campo. 
La diferencia entre Group By y DISTINCT es que con Group By Nos permitira ejecutar funciones de agregado con esta Clausula, lo que nos 
permite hacer cuentas sobre los campos agrupados, Sumatorias, Promedios.
   Select Precio from Autos Group by Precio Order by Precio DESC

5) WHERE => Nos permite Buscar o Filtrar Registros segun los valores de ciertos campos.


DELETE en FK: Si quiero eliminar algun Valor de la Tabla A que pertenece a algun registro de la FK de la tabla B saltara el error. Esto
es para prevenir dejar registros Inconsistentes.


                                                     2) Funciones de Agregado

1) Funcion Min-Max: Estas funciones me permitiran acceder al registro de mayor o menor valor. Tambien se puede usar para elementos VarChar,
Este devolvera los registros ordenados alfabeticamente. EJ: Select Max(fecha) as Fecha from Pago

2) Funcion SUM: Esta funcion permitira sumar registros. A esta funcion le podemos pasar varios campos para sumar. Tambien le puedo 
concatenar un + para sumarle otros valores que puedan venir por parametros o fijos. Dentro del Parentesis no debido a que si lo 
colocamos dentro del Parentesis por cada registro realizara es operacion

EJ: Select Sum(Kilometraje) from Autos.  Select Sum(Precio)*1.21 from Autos.

3) Funcion AVG: Esta nos permite calcular un promedio de un campo numerico que le pasemos segun su cantidad de registros. 
Select AVG(Precio) from Autos.

4) Funcion Count: Cuenta la cantidad de registros que tengo en mi tabla. Select Count(*) from Autos

5) Funcion Having: Esta Funcion Trabaja con la Funcion Count y Group By. Es similar al Where, pero este trabaja Si existe con Group By. Trabaja 
Con un conjunto de registros. Cuando ejecutas una consulta que tiene una cláusula GROUP BY, el HAVING te permite filtrar por las filas 
una vez agrupadas.
EJ: Select estado from turno Group by estado Having Count(estado) = 2

La funcion Having, a diferencia de Where, permite Usar Alias y Funciones agregadas para Filtrar, en cambio Where Solo usa el Nombre de 
las columnas para el filtro, en ese Sentido Having es mas Flex.


                                                     3) Operadores Logicos

1) AND: Concatenamos varias condiciones en la Clausula WHERE, todas estas condiciones se deben cumplir para que el registro sea devuelto.

2) OR: Concatenamos varias condiciones en la Clausula WHERE, Para que de Verdadero y devulva el registro debe cumplir al menos una de 
estas clausulas OR.

3) IN: Es un operador al cual le pasaremos valores que esperemos que nos devuelva. En el Siguiente ejemplo la tabla me devolvera los Autos
que valgan 150.000 y 200.000. EJ: Select * From Autos where Price IN(150.000, 200.000)

4) Like: Es un operador que me filtrara por valor Un valor Exacto. Tambien puedo usar los %% para especificarle si empieza, termina o 
Contiene Ese valor. EJ: Select * From Autos Where Nombre Like '%Coupe%'

5) NOT: Este me permite Negar el Operador LIKE e IN, de esta forma cumplirian una funcion opuesta, desfiltrando esos valores.
        Select * From Autos Where Nombre NOT Like '%Coupe%'

6) BETWEEN: Este Operador me permite filtrar en un Rango. Puede Tener un Rango Numerico, Un Rango de Fechas o Un Rango de textos
(Ordenados por el orden del Abecedario). 
            EJ: Select * From Autos Where Price BETWEEN 100.000 and 200.000.
            EJ: Select * from Turno Where Fecha BETWEEN '2024-01-25' and '2024-02-28'

                                                    4) Store Procedures

STORE PROCEDURE: Es una Consulta SQL que creamos y la empaquetamos o enlatamos. Estos Store Procedures tienen la finalidad de realizar
Acciones Concretas, O Multiples acciones concretas.

ANSI-NULL: Si yo tengo esta funcion en ON y busco valores NULL en mi Store Procedure esta no me va a devolver Nada, Anula el Retorno de
Valores NULL. Si quiero que me devuelva los NULL es tan sencillo como colocar ANSI_NULLS OFF.

QUOTED_IDENTIFIER: Permite Nombrar Tablas como palabras Reservadas si la coloco entre ""


                                                    5) Declarar variable

Una variable es un espacio de memoria que nos permitira alojar un valor en la memoria. Para Declarar una variable deberemos Usar 
la Palabra Declare. EJ: DECLARE @Nombre Char(7) = 'Ejemplo'. 
Si no inicializo el valor de la variable esta tendra por defecto NULL.

Si yo quiero asignar el Valor de una Variable a Otra varible puede llegar a Pasar que la varible a la cual le quiera sacar el Valor 
Sea Null, en estos casos nos conviene usar la Funcion ISNULL(), esta evalua y en el caso de que la varible sea null se le dara un 
valor por defecto que nosotros coloquemos. EJ: @variable = ISNULL(@Variable2, 'ERROR') as valor

                                                     6) SUBCONSULTAS

Una SUBCONSULTA es una Sentencia SELECT dentro de otra Sentencia SELECT, Para hacer esto lo debo hacer Antes del FROM y hacerlo entre 
Parentesis. Como aclaracion Los SubQuerys no pueden devolver mas de un valor por registro de Query principal.

Select Nombre, idPais, observacion
(select pais from Pais ps WHERE ps.idPais = pa.idPais) as Descripcion
From pacientes pa 
Where IdPaciente = @Variable

                                                    7) Estructuras de Control

Estructuras de Control: Son Estructuras que vamos a poder usar en SQL Server para evaluar un bloque de codigo y tomar deciones.

1) IF: Este nos sirve para evaluar el valor de una variable o de una consulta y si se cumple ejecutar acciones. Este por defecto 
    solo tomara como dentro del IF a la primera linea que este por debajo de ella(al igual que en C#) pero si quisiera armar un 
    por si se cumple la condicion debere usar BEGIN que iniciara el bloque y END lo terminara (como si fueran las { }).
        EJ: IF @Id = 7
            BEGIN
            select * from paciente where IdPaciente = @Id
            print 20
            END

2) EXISTS: Esta Funcion me permite evaluar si existe uno mas registros de determinada consulta. A este se lo suele usar con IF, para 
decir que SI Existe haga tal cosa, Sino tal otra. 
EJ: IF EXISTS(select * from Autos where Id = 1)
    Delete from Autos where Id = 1

3) WHILE: Esta Estructura nos permite ejecutar un bloque de codigo hasta que se deje de cumplir una condicion. Tambien deberemos usar 
la Estructura BEGIN y END.

4) RETURN: Return basicamente lo que hace es cortar la ejecucion del Codigo. Se suele usar en funciones y procedimientos almacenados para
finalizar la ejecución del Script actual y devolver el control al llamador de la función o procedimiento. Todo lo que haya despues de un 
bucle tampoco sera ejecutado, el return Elimina toda la ejecucion del Script. 

5) BREAK: El BREAK Es similar a RETURN, pero este a diferencia de RETURN solo rompe el ciclo donde se encuentra, Este sale del ciclo pero
el resto de la ejecucion del SCRIPT se mantiene. Basicamente el BREAK lo que hace es interrumpir un WHILE.

6) TRY-CATCH: Se encarga de manejar los errores en tiempo de ejecucion, los errores no controlados. En este caso lo que hace SQL 
al detectar el Error con el Try Catch es parar la ejecucion y devolver la Consola.

BEGIN TRY
END TRY
BEGIN CATCH 
END CATCH

7) CASE: Este condicional nos permite elegir una ruta segun el valor de una variable o un campo, un Swich basicamente. A Este por ejemplo
lo podemos usar en el SELECT y colocar al CASE como una Columna mas a devolver. La Opcion de default se coloca con ELSE.
         EJ: set @COLOR = (CASE WHEN @valor = 10 THEN 'ROJO'
                                WHEN @valor = 20 THEN 'Verde'
                                WHEN @valor = 30 THEN 'AZUL'
                            ELSE 'GRIS'
                                END)


                                                 8) DATOS UTILIES

Para seleccionar el ultimo ID Insertado este tiene que estar configurado con Identity. Para acceder a este ultimo valor 
debo llamar a la varible del sistema @@IDENTITY.

                                                8.1) Ver un SP desde la Consola

sp_helptext *Store procedure*.

Tambien desde el menu tools puedo ir a modificar los ShortCuts.

                                         9) Alter Table / Column y Drop Column

Alter Table: Con la sentencia Alter Table podemos modificar la Estructura de una tabla. 
1) Alter Table Paciente ADD Numero int. 2)  Alter Table Paciente Drop Column Numero. 
3) Alter Table Paciente Alter Column Numero smallint

                                        9.1) Crear Script de CREATE TABLE

Debo seleccionar una tabla desde el explorardor, click derecho Script Table y Creat TO.

1) SET ANSI_NULLS: activa o desactiva la comparación contra valores NULL.

2) GO: separa una instrucción de otra

3) SET QUOTED_IDENTIFIER: activa o desactiva el uso de comillas dobles para palabras reservadas.

4) CLUSTERED: genera una indexación que define cómo se organizan los datos en una tabla en función de la clave primaria.


                                            10) Definir una FK desde T-SQL

                                                  Alter Table Paciente
                                                ADD Foreign KEY (IdPais) 
                                                REFERENCES  Pais(idPais)


                                                11) CREATE FUNCTION

                                        CREATE FUNCTION MyFunction (@parametro int)
                                        RETURNS int
                                        as
                                        BEGIN
                                            set @var = @var * 5
                                            return @var
                                        END

                                                      LLAMADO

                                              select dbo.nombrefun (20)

Las Funciones si o si las debo llamar desde el select y le debo colocar su esquema dbo. Un Esquema es un grupo o un espacio de nombres en
el que podemos agrupar las tablas y los SP.


                                                    12) TRUNCATE

TRUNCATE lo que hace es eliminar por completo los registros de una tabla y resetear los campos que tengan configurado IDENTITY.

EJ: TRUNCATE table Paciente

                                                13) Funciones LEFT and RIGHT

Son funciones para tratar variables de tipo CHAR o VARCHAR. Nos permiten conseguir determinados caracterers que esten a la derecha o
a la izquierda. Para esto le tengo que pasar la cadena y la cantidad de caracteres que quiero seleccionar.

Select LEFT(Nombre, 1), LEFT(Apellido, 1) from paciente

                                                  14) Funcion LEN

Es una FUNCION que se encarga de contar la cantidad de caracteres que tiene una cadena de caracteres. Esto me sirve para usar en el 
WHERE cuando quiera filtrar texto que no tenga mas de tantos caractereres o cosas similares. Tambien lo puedo Combinar con LEFT y 
RIGHT.
EJ: select Nombre from Medico where Len(Nombre) > 10
                                                15) Funcion LOWER y UPPER

Estas Funciones nos va a permitir formatear variables de Tipo Texto. Lower Sera para llevar a Minusculas todo el texto y Upper a Mayus.

EJ: Select TOP 1  Upper(LEFT(Nombre, 1)) + LOWER(RIGHT(Nombre, LEN(Nombre)-1)) from Paciente

                                                16) Funcion Replace

Nos permite reemplazar un caracter por otro. Sirve cuando quiero formatear caracteres incorrectos que se cargaron. Por 
Ejemplo si se cargo un @ en vez de una A. El primer parametro es la cadena, el segundo el caracter  a reemplazar y el 
tercero el reemplazo.

Select REPLACE('Mi @migo Pepe', '@', 'A') 

                                                17) Funcion REPLICATE

La funcion Replicate me permite repetir un Caracter o una cadena de caracteres la cantidad de veces que le especifiquemos.
Con esta funcion podemos formatear numero, pero necesitaremos de otra funcion para poder hacerlo.

Select REPLICATE(Nombre, 5) Nombre  from Paciente  

                                                18) Funcion LTRIM y RTRIM

Me permite eliminar los espacios (espacios vacios) de una cadena de caracteres tanto a la derecha Como a la izquierda. Lo puedo mandar 
de forma anidada asi se borra los espacios a la izquierda y a la derecha.
 
EJ: Select LTRIM(RTRIM(Nombre)) from Paciente

                                                    19) Funcion CONCAT

Me permite concatenar 2 o mas Valores. EJ: CONCAT(@Var1, @Var2)

                                              20) Funcion GETDATE y GETUTCDATE

Estas funciones se las suele utilizar cuando necesitamos almacenar la fecha y la hora de cuando se creo el registro. GETDATE() Nos devolvera
la hora exacta en la cual esta instalado el Sistema de Base de Datos, en cambio GETUTCDATE() nos devolvera la hora sin la diferencia horaria.
Hay que tener en cuanta que si el servidor se encuntra en un lugar distinto de donde quiero consultar los datos vamos a tener que manejar 
esa hora, debido a que seran horas distintas debido al UTC.

EJ: Insert Into Ejemplo (FechaLog) values (GETDATE())

                                                    21) Funcion DATEADD

Esto nos permite agregarle Dias, Meses y Años a una Fecha Date o Datetime. tambien en el caso de DateTime puedo agregarle Horas y Minutos.
La Funcion DATEADD() recibe 3 Parametros, 1) El Intervalo de Tiempo, es decir que quiero modificar, si el dia, Mes, Año, ETC. 
2) La Cantidad de Dias/Meses/Años que quiero agregar. 3) Sobre que Fecha quiero hacer esta modificacion.

Update Ejemplo Set MiFecha = DATEADD(day, 3, MiFecha)

                                                    21) Funcion DATEDIFF

Esta Nos Devuelve la diferencia entre 2 fechas, segun el intervalo de tiempo que especifiquemos (dias, meses, años). Esta Funcion tambien
Recibe 3 parametros: 1) El intervalo. 2) La primera Fecha a Comparar por la diferencia. 3) La segunda fecha a comprar por la diferencia.

                                                    22) Funcion DATEPART

Esta Funcion nos permite tener el intervalo especifico de una Fecha. Para esto le tenemos que pasar 2 parametros: 1) El Intervalo 
2) La Fecha.

EJ: Select DATEPART(month, GETDATE())

                                                    23) Funcion ISDATE

Es una funcion que nos permite evaluar si una fecha consta de un formato correcto, por ello esta nos devolvera un TRUE o FALSE. Se lo 
suele usar con IF para ejecutar una accion si la fecha es correcta o incorrecta.

EJ: Select ISDATE('20240123')

                                                  24) FUNCIONES CAST y CONVERT

Las Funciones CAST y CONVERT son funciones de conversion de tipos de datos (puedo convertir un campo de un tipo de dato o una variable
a otro tipo de dato). Estas son similares entre si, solo que CAST es mas generica y solo me deja castear Tipo de datos de la misma familia
(Numero con numero y texto con texto), en cambio CONVERT es mas flexible con eso y mediante parametros puedo hacer mas conversiones, especialmente
cuando se trata de fechas.

Parametros de Convert: 1) El Tipo de Dato al Cual quiero convertir mi variable o Campo. 2) La varible o campo. 3) OPCIONAL para DateTime,
en este le tengo que pasar el formato de fecha que quiero que me devuelvan.

1) EJ: Insert into Ejemplo (Dinero) values (CAST(500.40 as int))

2) EJ: SELECT CONVERT(DATE, MiFecha, 112) from MiTabla

                                              25) Estructura De TRANSACCIONESS

La Estructura de las Transacciones se suele usar en las funciones o los SP, para que si ejecuto un SP por ejemplo y en la mitad del SP 
capturo un Error con el TRY CATCH, La primera mitad del SP no se ejecute, que vuelva atras los cambios que realizo. En sintesis, esta
estructura se la suele utilizar para una parte del codigo en el que estamos actualizando, Insertando o Eliminando Datos.
Para establecer el inicio de la Transaccion colocaremos BEGIN TRAN. Esta Transaccion no se terminara hasta que se encuentre con un 
COMMIT o un ROLLBACK.

BEGIN TRY
    BEGIN TRAN
        DELETE FROM Autos
    COMMIT TRAN
END TRY

BEGIN CATCH
    ROLLBACK TRAN
END CATCH

Begin TRAN 
    Delete from Autos where Precio = 160.000
IF @@RowCount = 1
    COMMIT Tran 
Else 
    ROLLBACK Tran

1) @@RowCount: Variable del sistema que me permite contar cuantas celdas fueron actualizadas en una ejecucion.


                                                     26) JOINS y UNIONS

1) JOINS: Estos me permiten conectar 2 o mas tablas entre si y obtener resultados. Para poder cruzar las tablas necesitaremos darle un 
nombre o alias a cada tabla. Dentro de los JOINS encontramos a 1)INEER JOINS. 2) LEFT JOIN. 3) RIGHT JOIN.

1.1) INNER JOIN: Con esta Clausula traeremos los registros que existen en ambas tablas a la vez.

Select * from Paciente P
INNER JOIN TurnoPaciente TP 
ON TP.IdPaciente = P.IdPaciente

1.2) LEFT JOIN: Con esta Clausula traeremos Todos los registros de la Tabla A y los que coicidan con respecto a la clausula ON de La 
Tabla B.

Select * From Paciente P
LEFT JOIN TurnoPaciente T
ON T.idPaciente = P.idPaciente  

1.3) RIGHT JOIN: Al Reves de LEFT JOIN.

1.4) FULL OUTER JOIN: Selecciona Todo de ambas tablas.

1.5) Consideraciones Con INNER JOIN: Siempre que podamos deberiamos usar las PK de las tablas para realizar un INNER JOIN, aunque no esta 
mal utilizar otros campos lo recomendados es cruzar PK, debido a que el Rendimiento del SQL es mayor cruzando las PK que otros campos.
Otra Buena Practica es colocar en la comparacion del ON la tabla B primero que la tabla A "ON B.idTabla = A.idTabla".
Esto tambien por una cuestion de Rendimiento.

2) UNIONS: La diferencia entre la clausula UNION con la clausula INNER es que UNION nos permite unir 2 Resultados de 2 consultas diferentes.
Es decir con UNION yo puedo hacer 2 Consultas y que esta me devuelva un registro fusionado con ambas consultas. Si los registros son 
repetidos UNION los fusionara en uno solo. Esto es Util cuando quiero Seleccionar de una misma tabla registros discriminados por WHERE, ya
que UNION solamente puede unir consultas de Tablas que tengan la misma estructura (misma cantidad de Campos y tipo de dato).

Select * from Autos where Price = 55000
UNION
Select * from Autos where Price > 150000

2.1) UNION ALL: La unica diferencia con UNION es que esta no elimina la repeticion de registros cruzados, trae directamente todos los 
registros que encuentra.

                                             27) Funciones definidas por el usuario

1) Funciones Escalares: Son Funciones que nos permiten recibir uno o mas parametros y devolver un  valor de tipo especifico.
Create Function VerPais(
	@idpaciente paciente
	)
RETURNS VARCHAR(50)
as
BEGIN
	declare @aux varchar(50)
	set @aux = (Select PA.Pais From Paciente P
	INNER JOIN Pais PA
	ON PA.IdPais = P.idPais
	where idPaciente = @idpaciente)
	RETURN @aux
END

Llamado: Select dbo.VerPais

2) Funciones De Tipo Tabla: Nos permiten Recibir Uno o Mas parametros pero en vez de devolver un resultado nos permitira retornar una 
tabla o un Conjunto de registros.

Create FUNCTION ListaPaises(@Nombre Varchar(20),@ID Char(3))
RETURNS @Paises Table(Descripcion VarChar(50), idPais Char(3))
as
BEGIN		
	Insert Into @Paises (Descripcion, idPais) values (@Nombre, @ID)
	RETURN
END

Llamado: Select * from dbo.ListaPaises('Sri Lanka', 'GOD')

                                                    28) Tablas Temporales

1) Tabla Temporal En Memoria: Una tabla temporal en memoria va a existir mientras el Script se este ejecutando, una vez termine el 
script esta tabla en memoria se destruye. Para declarar una tabla en memoria usamos DECLARE @NombreTabla TABLE (@Campo1, @Campo2)

EJ: Declare @MiTabla Table(id int Identity (1,1), pais varchar(50))

2) Tabla Temporal Fisica: La tabla temporal Fisica cuando la creamos va a existir en la base de datos hasta que reiniciemos el servicio
de Base de Datos. Mientras el Motor este corriendo esta tabla va a seguir existiendo. Esta tabla se crea como una tabla normal solo que 
al nombre se le agrega una #.

EJ: Create Table #MiTable(
    id int Identity(1,1),
    pais varchar(50)
)

Drop Table #MiTabla

3) Insertar Registros en una Tabla: insert into @turnos (idturno, idpaciente)
                                    select TP.idturno, P.idPaciente from Paciente P
                                    INNER JOIN TurnoPaciente PA
                                    ON TP.idPaciente = P.idPaciente

4) Recorrer Tabla: Para Recorrer una tabla la hacemos con un bucle WHILE.
                    
                    @Declare @X int, total int
                    set @i = 1
                    set @total = (SELECT Count(*) from @turnos)
                    
                    WHILE @i <= @total
                    BEGIN

                    IF(select idpaciente from @turnos where id = @i) <> 8
                        delete from @turnos where id = @i 

                        set @i = @i + 1
                    END   

                    select * from @turnos 

                                                        29) VISTA

Se la crea desde el EXPLORER en la carpeta Views y ahi puedo seleccionar las tablas que quiero ver. Lo que hace una Vista es almacenar 
una consulta en la BD y cuando ejecutamos la vista lo que hace es ejecutar hace consulta y actualizar esos datos. En sintesis una vista
viene a ser una especie de tabla virtual que nos sirve para guardar una consulta especifica.

CREATE VIEW *Nombre* AS 
* Consulta *

Para llamar a esta vista lo hacemos como si fuera una tabla por su nombre. -> Select * from MiVista

Una vista en SQL es una tabla virtual que se deriva de una o más tablas existentes en una base de datos. En lugar de 
almacenar los datos físicamente, una vista es una consulta predefinida que se puede utilizar para recuperar los datos de 
una o más tablas en una base de datos.
Una vista se crea mediante una instrucción SELECT y puede contener cualquier cláusula válida de SQL, como WHERE, GROUP BY,
ORDER BY y JOIN. Una vez creada la vista, se puede consultar como si fuera una tabla real, lo que significa que se pueden
realizar consultas y aplicar filtros, y los resultados se devolverán como si se hubieran consultado directamente desde una 
tabla.

Las vistas son útiles en situaciones en las que se requiere una consulta frecuente de una misma tabla o combinación de 
tablas, ya que pueden simplificar la consulta y reducir la complejidad de las consultas que se ejecutan con frecuencia. 
También se pueden utilizar para restringir el acceso a datos confidenciales o para proporcionar una capa adicional de
seguridad en una base de datos.

                                                      30) TRIGGERS

TRIGGERS: Un Trigger es un desencadenador o disparador de un Evento. Tenemos 3 eventos que desencadenan un Triggers: 1) Insert. 2)Update.
3) Delete. Nosotros podemos crear un Trigger cuando suceda alguno de esos 3 eventos, en relacion a la informacion que actualizo esa 
accion. Vamos a poder guardar ese registro nuevo en el LOG, guardar ese nuevo registro en una tabla.

1) Trigger Insert EJ: CREATE TRIGGER *Nombre Trigger* ON *La tabla sobre la cual se dispara el Trigger* AFTER INSERT

2) Trigger Delte EJ: CREATE TRIGGER borrado ON Paciente FOR Delete as


                                                    31) Crear BackUps

1) Necesitamos crear una carpeta en nuestro sistema para guardar los BackUps. 2) Vamos a nuestra BD desde el explorer, a la opcion de 
Task y a BackUp. 3) Dentro del BackUp podremos elegir si hacer un BackUp FULL (Con la toda la estructura y registros) o uno diferencial
(Solo hace un BackUp de loss objetos nuevos con respecto a un BackUp anterior)

1.1) Crear BackUp desde Script: declare @var varchar(100) = Replace(Concat('D:\BackUp_BD\NombreBack', Convert (char(8),GETDATE(), 112), 
								Replace (Convert (char(5),GETDATE(), 108), ':','') ,'.bak'),' ', '')
								BackUp DATABASE CentroMedico 
                                TO DISK = @var
                                WITH NO_COMPRESSION, NAME='NombreBack'

                                                    32) Restore BackUp

1) Deberemos ir a Database desde el explorador y entrar en Restore Database. 2) Seleccionamos DEVICE y buscamos nuestro archivo.
3) En la Opcion de destino tenemos que asegurarnos que este seleccionado la Base de Datos que queremos Restaurar.

                                                    33) SCHEDULED JOBS

1) SCHEDULED JOBS: Son basicamente tareas programadas que se realizan automaticamente, estas estan programadas por el SQL Agent.
El SQL Server Agent Es un Componente dentro del SQL Server que administra las tareas programadas. Las Tareas programadas son un 
proceso el cual nosotros podemos crear y  decirle que ejecute ciertos Scripts en determinados momentos.

Para crear un JOB debo ir a la carpeta de JOB y Luego darle click a NEW JOB. Ahi encontraremos las configuraciones del Nombre, del nivel
de permisos que necesita ese JOB, la Descripcion, los Procesos que va a Ejecutar(Store Procedures por Ejemplo). Tambien se encuentra la
Config de Schedule, ahi puedo configurar cada cuanto se va a ejecutar ese Script.

2) Configurar el SCHEDULED: 1) le Colocaremos el Nombre y a que usuario pertenece. 2) Si nuestra tarea es de varios pasos lo podremos 
configurar desde STEPS, si tiene una sola solo agregaremos un STEP. 3) En el step configuramos un Nombre, El tipo de Comando (normalmente
T-SQL), la BD sobre la cual se va a ejecutar y los comandos. 4) Vamos a Scheduled y lo configuramos cada cuanto queremos que se ejecute 
esa accion.


                                                    34)

                                                    40) Sintaxis General

0) GO: Delimita cada Bloque de Ejecucion en SQL.

1) Select Nombres, Precios from Auto

2) Insert into Auto (Nombre, Precio) values ('Corola', 5000), ('Sprinter', 6000)

3) Update Auto set Nombre = 'Toreno', Precio = 45000 WHERE Id = @MyID

4) Delete From Auto where Id = @MyID

5) TOP: Select Top 5 * Pacientes 

6) Order By: Select Nombre, Precio from Auto Order By Precio DESC

7) DISTINCT: Select DISTINCT Tanque from Autos.

8) Group By: Select Precio from Autos Group by Precio

9) Min-Max: Select Max(Precio) as Precio from Autos // Select Min(Precio) as Precio from Autos

10) Sum: Select Sum(Precio)*1.21 From Autos where id = @MyId

11) AVG: Select AVG(Precio) from Autos

12) Count: Select Count(*) from Autos

13) Having: Select Price from Autos Group by Price Having Price < 300000

14) IN: Select * From Autos Where Anio IN('1990', '1998') 

15) Like: Select * From Autos Where Nombre Like '%Coupe%'

16) NOT: Select * From Autos Where Nombre NOT Like '%Coupe%'
 
17) BETWEEN: Select * from Turno Where Fecha BETWEEN '2024-01-25' and '2024-02-28'

18) SP: CREATE PROCEDURE *Nombre* *@Parametros* as *Acciones SQL*

19) SP-Llamado: Exec SP_MyStore *Parametro1, Parametro2*

20) Declarar Variable: DECLARE @Nombre Char(7) = 'Ejemplo' // Set @Nombre = 'Hola'

21) ISNULL: @variable = ISNULL(@Variable2, 'ERROR') as valor

22) TYPE: CREATE TYPE *Nombre*  from *tipo de dato* null/not null

23) IF:  IF @Id > 7
         BEGIN
         select * from paciente where IdPaciente = @Id
         print 20
         END

         Else
         BEGIN
         select * from paciente where IdPaciente = 0
         print 0
         END

24) EXIST: IF EXIST(select * from Autos where Id = 1)
           Delete from Autos where Id = 1

25) CASE: set @COLOR = (CASE WHEN @valor = 10 THEN 'ROJO'
                             WHEN @valor = 20 THEN 'Verde'
                             WHEN @valor = 30 THEN 'AZUL'
                             END)

26) Operador Numerico Distinto: <>

27) Alter Table: 1) Alter Table Paciente ADD Numero int. 2)  Alter Table Paciente Drop Column Numero.  3) Alter Table Paciente Alter Column Numero smallint

28) Drop Table: Drop Table MiTabla

29) TRUNCATE: TRUNCATE table Paciente

30) LEFT-RIGHT: Select LEFT(Nombre, 1), LEFT(Apellido, 1) from paciente

31) LEN(): select Nombre from Medico where Len(Nombre) > 10

32) Lower y Upper: Select TOP 1  Upper(LEFT(Nombre, 1)) + LOWER(RIGHT(Nombre, LEN(Nombre)-1)) from Paciente

33) REPLACE: Select REPLACE('Mi @migo Pepe', '@', 'A') // Select REPLACE(Nombre, 'S', '@') Nombre  from Paciente  

34) LTRIM y RTRIM: Select LTRIM(RTRIM(Nombre)) from Paciente

35) CONCAT: CONCAT(@Var1, @Var2)

36) GETDATE:  Insert Into Ejemplo (FechaLog) values (GETDATE())

37) DATEADD: Update Ejemplo Set MiFecha = DATEADD(day, 3, MiFecha)

38) DATEDIFF: Select DATEDIFF(year, GETDATE(), 20170123)

39) DATEPART: Select DATEPART(month, GETDATE())

40) ISDATE: IF ISDATE(Fecha)

41) CAST: Insert into Ejemplo (Dinero) values (CAST(500.40 as int))

42) CONVERT: Select CONVERT(Date, MiFecha, 112) from MiTabla

43) Transacciones: BEGIN TRY
                        BEGIN TRAN
                            DELETE FROM Autos
                        COMMIT TRAN
                    END TRY

                    BEGIN CATCH
                        ROLLBACK TRAN
                    END CATCH

44) JOINS: Select * From Paciente P
           INNER/LEFT/RIGHT JOIN TurnoPaciente T
           ON P.idPaciente = T.idPaciente

45) UNIONS: Select * From Paciente P where Id= 44
            UNION
            Select * From Paciente P where Id= 33

46) Tabla Temporal en memoria: Declare @MiTabla Table(id int Identity (1,1), pais varchar(50))

47) Recorrer Tabla: @Declare @X int, total int
                    set @i = 1
                    set @total = (SELECT Count(*) from @turnos)
                    
                    WHILE @i <= @total
                    BEGIN
                    IF(select idpaciente from @turnos where id = @i) <> 8
                        delete from @turnos where id = @i 

                        set @i = @i + 1
                    END   
                    select * from @turnos 

48) TRIGGERS: CREATE TRIGGER *Nombre Trigger* ON *La tabla sobre la cual se dispara el Trigger* 
              AFTER INSERT AS
              IF (SELECT idPais FROM Inserted) = 'ARG'
                 Insert into PacienteLog (Idpais, idpaciente, fechaAlta)
                 Select Idpais, idpaciente, GETDATE() from Inserted i






Shor-Cuts: Ctrl-N(Abre un Query en Blanco). Ctrl-R(Oculta Ventana de mensajes). F8(Object Explorer). Ctrl-Alt-L(Mostrar Solution Explorer)
Ctrl-F5(Permite Ejecutar Parse). Ctrl-Shift-U(Cambiar el texto seleccionado a mayúsculas). Ctrl-Shift-L(Todo Minusculas).
Ctrl-K-C (Comentar la codigo). Ctrl-K-U (Descomentar la codigo.) Ctrl-Shift-Flecha(Para Seleccionar Palabras)

Ctrl + D: Modo de visualización de cuadrícula. Ctrl + T: Modo de visualización de texto.

